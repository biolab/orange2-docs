
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Settings and Controls &mdash; Orange Documentation v2.7.8</title>
    
    <link rel="stylesheet" href="../../_static/orange.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.7.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Orange Documentation v2.7.8" href="../../index.html" />
    <script type="text/javascript" src="../../_static/copybutton.js"></script>

  </head>
  <body>
	<div id="container">
    <div class="border1"></div>
    <div class="border2"></div>
    <div class="borderv">
        <div id="header">
			<div id="orangeimg"><h1><a href="http://orange.biolab.si"><img src="../../_static/orange-logo-w.png" alt="Orange" /></a></h1></div>

            <div id="cse-search-box" style="height: 22px;"></div>
            <div id="underimg"></div>
        </div>
    </div>
    <div class="border2"></div>
    <div class="border1"></div>

    <div id="main">
        <div class="border1"></div>
        <div class="border2"></div>
        <div class="borderv">
            <div id="maininner">
            <p style="font-size: 32px;">
                This is documentation for Orange 2.7. For the latest documentation, 
                <a href="http://orange.biolab.si/docs">
                see Orange 3</a>.
            </p>
 

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
    <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
           <p><a class="uplink" href="../../index.html">Orange Documentation v2.7.8</a></p>
           <ul>
<li><a class="reference internal" href="#">Settings and Controls</a><ul>
<li><a class="reference internal" href="#widgets-settings">Widgets Settings</a></li>
<li><a class="reference internal" href="#controls-and-owgui">Controls and OWGUI</a></li>
<li><a class="reference internal" href="#context-dependent-settings">Context dependent settings</a></li>
<li><a class="reference internal" href="#using-domaincontexthandler">Using <tt class="docutils literal"><span class="pre">DomainContextHandler</span></tt></a></li>
<li><a class="reference internal" href="#defining-new-context-handlers">Defining New Context Handlers</a></li>
<li><a class="reference internal" href="#saving-and-loading-settings">Saving and loading settings</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
    
  <div class="section" id="settings-and-controls">
<h1>Settings and Controls<a class="headerlink" href="#settings-and-controls" title="Permalink to this headline">¶</a></h1>
<p>In the <a class="reference internal" href="basics.html"><em>previous section</em></a> of our tutorial we
have just built a simple sampling widget. Let us now make this widget
a bit more useful, by allowing a user to set the proportion of data
instances to be retained in the sample. Say we want to design a widget
that looks something like this:</p>
<img alt="../../_images/dataSamplerBWidget.png" src="../../_images/dataSamplerBWidget.png" />
<p>What we added is an Options box, with a spin entry box to set the
sample size, and a check box and button to commit (send out) any
change we made in setting. If the check box with &#8220;Commit data on
selection change&#8221; is checked, than any change in the sample size will
make the widget send out the sampled data set. If data sets are large
(say of several thousands or more) instances, we may want to send out
the sample data only after we are done setting the sample size, hence
we left the commit check box unchecked and press &#8220;Commit&#8221; when we are
ready for it.</p>
<p>This is a very simple interface, but there is something more to
it. We want the settings (the sample size and the state of the commit
button) to be saved. That is, any setting we made, after closing our
widget (or after going out of Orange application that includes this
widget, or after closing Orange Canvas), we want to save so that the
next time we open the widget the settings is there as we have left
it. There is some complication to it, as widget can be part of an
application, or part of some schema in the Canvas, and we would like
to have the settings application- or schema-specific.</p>
<div class="section" id="widgets-settings">
<h2>Widgets Settings<a class="headerlink" href="#widgets-settings" title="Permalink to this headline">¶</a></h2>
<p>Luckily, since we use the base class <tt class="xref py py-obj docutils literal"><span class="pre">OWWidget</span></tt>, the settings
will be handled just fine. We only need to tell which variables we
will use for the settings. For Python inspired readers: these
variables can store any complex object, as long as it is
picklable. In our widget, we will use two settings variables, and we
declare this just after the widget class definition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">OWDataSamplerB</span><span class="p">(</span><span class="n">OWWidget</span><span class="p">):</span>
    <span class="n">settingsList</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;proportion&#39;</span><span class="p">,</span> <span class="s">&#39;commitOnChange&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Any setting has to be initialized, and then we need to call
<tt class="xref py py-obj docutils literal"><span class="pre">loadSettings()</span></tt> to override defaults in case we have used
the widget before and the settings have been saved</p>
<div class="highlight-python"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commitOnChange</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadSettings</span><span class="p">()</span>
</pre></div>
</div>
<p>Now anything we do with the two variables (<tt class="xref py py-obj docutils literal"><span class="pre">self.proportion</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">self.commitOnChange</span></tt>) will be saved upon exiting our
widget. In our widget, we won&#8217;t be setting these variables directly,
but will instead use them in conjunction with GUI controls.</p>
</div>
<div class="section" id="controls-and-owgui">
<h2>Controls and OWGUI<a class="headerlink" href="#controls-and-owgui" title="Permalink to this headline">¶</a></h2>
<p>Now we could tell you how to put different Qt controls on the
widgets and write callback functions that set our settings
appropriately. This is what we have done before we got bored with it,
since the GUI part spanned over much of the widget&#8217;s code. Instead, we
wrote a library called <a class="reference internal" href="owgui.html#module-OWGUI" title="OWGUI"><tt class="xref py py-mod docutils literal"><span class="pre">OWGUI</span></tt></a> (I never liked the name, but could never
come up with something better). With this library, the GUI definition
part of the options box is a bit dense but rather very short</p>
<div class="highlight-python"><div class="highlight"><pre>        <span class="n">box</span> <span class="o">=</span> <span class="n">OWGUI</span><span class="o">.</span><span class="n">widgetBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">controlArea</span><span class="p">,</span> <span class="s">&quot;Info&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infoa</span> <span class="o">=</span> <span class="n">OWGUI</span><span class="o">.</span><span class="n">widgetLabel</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="s">&#39;No data on input yet, waiting to get something.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infob</span> <span class="o">=</span> <span class="n">OWGUI</span><span class="o">.</span><span class="n">widgetLabel</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="n">OWGUI</span><span class="o">.</span><span class="n">separator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">controlArea</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span> <span class="o">=</span> <span class="n">OWGUI</span><span class="o">.</span><span class="n">widgetBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">controlArea</span><span class="p">,</span> <span class="s">&quot;Options&quot;</span><span class="p">)</span>
        <span class="n">OWGUI</span><span class="o">.</span><span class="n">spin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&#39;proportion&#39;</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                   <span class="n">label</span><span class="o">=</span><span class="s">&#39;Sample Size [%]:&#39;</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkCommit</span><span class="p">])</span>
        <span class="n">OWGUI</span><span class="o">.</span><span class="n">checkBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&#39;commitOnChange&#39;</span><span class="p">,</span> <span class="s">&#39;Commit data on selection change&#39;</span><span class="p">)</span>
        <span class="n">OWGUI</span><span class="o">.</span><span class="n">button</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Commit&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="o">.</span><span class="n">setDisabled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We are already familiar with the first part - the Info group
box. To make widget nicer, we put a separator between this and Options
box. After defining the option box, here is our first serious OWGUI
control. Called a <tt class="xref py py-obj docutils literal"><span class="pre">spin</span></tt>, we give it place where it is
drawn (<tt class="xref py py-obj docutils literal"><span class="pre">self.optionsBox</span></tt>), and we give it the widget object
(<tt class="xref py py-obj docutils literal"><span class="pre">self</span></tt>) so that it knows where the settings and some other
variables of our widget are.</p>
<p>Next, we tell the spin box to be
associated with a variable called <tt class="xref py py-obj docutils literal"><span class="pre">proportion</span></tt>. This simply
means that any change in the value the spin box holds will be directly
translated to a change of the variable
<tt class="xref py py-obj docutils literal"><span class="pre">self.proportion</span></tt>. No need for a callback! But there&#8217;s
more: any change in variable <tt class="xref py py-obj docutils literal"><span class="pre">self.proportion</span></tt> will be
reflected in the look of this GUI control. Say if there would be a
line <tt class="xref py py-obj docutils literal"><span class="pre">self.proportion</span> <span class="pre">=</span> <span class="pre">70</span></tt> in your code, our spin box
control would get updated as well. (I must admit I do not know if you
appreciate this feature, but trust me, it may really help prototyping
widgets with some more complex GUI.</p>
<p>The rest of the OWGUI spin box call gives some parameters for the
control (minimum and maximum value and the step size), tells about the
label which will be placed on the top, and tells it which functions to
call when the value in the spin box is changed. We need the first
callback to make a data sample and report in the Info box what is the
size of the sample, and a second callback to check if we can send this
data out. In OWGUI, callbacks are either references to functions, or a
list with references, just like in our case.</p>
<p>With all of the above, the parameters for the call of
<a class="reference internal" href="owgui.html#OWGUI.checkBox" title="OWGUI.checkBox"><tt class="xref py py-obj docutils literal"><span class="pre">OWGUI.checkBox</span></tt></a> should be clear as well. Notice that this
and a call to <a class="reference internal" href="owgui.html#OWGUI.spin" title="OWGUI.spin"><tt class="xref py py-obj docutils literal"><span class="pre">OWGUI.spin</span></tt></a> do not need a parameter which
would tell the control the value for initialization: upon construction,
both controls will be set to the value that is pertained in the
associated setting variable.</p>
<p>That&#8217;s it. Notice though that we have, as a default, disabled all
the controls in the Options box. This is because at the start of the
widget, there is no data to sample from. But this also means that when
process the input tokens, we should take care for enabling and
disabling. The data processing and token sending part of our widget
now is</p>
<div class="highlight-python"><div class="highlight"><pre>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infoa</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> instances in input data set&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="o">.</span><span class="n">setDisabled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Sampled Data&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionsBox</span><span class="o">.</span><span class="n">setDisabled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infoa</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s">&#39;No data on input yet, waiting to get something.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infob</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">SubsetIndices2</span><span class="p">(</span><span class="n">p0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infob</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> sampled instances&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Sampled Data&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">commitOnChange</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
<p>You can now also inspect the <a class="reference download internal" href="../../_downloads/OWDataSamplerB.py"><tt class="xref download docutils literal"><span class="pre">complete</span> <span class="pre">code</span></tt></a>
of this widget. To distinguish it with a widget we have developed in the
previous section, we have designed a special
<a class="reference download internal" href="../../_downloads/DataSamplerB.svg"><tt class="xref download docutils literal"><span class="pre">icon</span></tt></a> for it. If you wish to test is
widget in the Orange Canvas, put its code in the <cite>orangedemo</cite> directory we
have created for the previous widget and try it out using a schema with
a File and Data Table widget.</p>
<img alt="../../_images/schemawithdatasamplerB.png" src="../../_images/schemawithdatasamplerB.png" />
<p>Well-behaved widgets remember their settings - the state of their
checkboxes and radio-buttons, the text in their line edits, the
selections in their combo boxes and similar. These settings are even
maintained across sessions. This document describes the Orange&#8217;s
methods that take care of that.</p>
<p>Orange doesn&#8217;t really save the state of the controls but instead
saves the value of the corresponding attributes. For a check box there
should be a corresponding widget&#8217;s attribute recording the check box&#8217;s
state so that when the user changes a check box, the attribute changes
and vice-versa. You can create such a link manually, or you can use
the <a class="reference internal" href="owgui.html"><em>OWGUI</em></a> module instead; for instance, for a check
box, use <a class="reference internal" href="owgui.html#OWGUI.checkBox" title="OWGUI.checkBox"><tt class="xref py py-func docutils literal"><span class="pre">OWGUI.checkBox()</span></tt></a>.</p>
<p>The settings fall into two groups. Some of them do not depend on
the data, while other are context-dependent. For the first to be saved
properly, you only need to list them in the <tt class="xref py py-obj docutils literal"><span class="pre">settingsList</span></tt>
in the widget definition, as already described.</p>
<span class="target" id="module-OWContexts"></span></div>
<div class="section" id="context-dependent-settings">
<h2>Context dependent settings<a class="headerlink" href="#context-dependent-settings" title="Permalink to this headline">¶</a></h2>
<p>Context dependent settings usually depend upon the attributes that
are present in the data set domain. For instance, the scatter plot
widget contains settings that specify the attributes for x and y axis,
and the settings that define the color, shape and size of the examples
in the graph. An even more complicated case is the widget for data
selection with which one can select the examples based on values of
certain attributes. Before applying the saved settings, these widgets
needs to check their compliance with the domain of the actual data
set. To be truly useful, context dependent settings needs to save a
setting configuration for each particular data set used. That is, when
given a particular data set, it has to select the saved settings that
is applicable and matches best currently used data set.</p>
<p>Saving, loading and matching contexts is taken care of by context
handlers. Currently, there are only two classes of context handlers
implemented. The first one is the abstract <tt class="xref py py-class docutils literal"><span class="pre">ContextHandler</span></tt>
and the second one is <tt class="xref py py-class docutils literal"><span class="pre">DomainContextHandler</span></tt> in which the
context is defined by the data set domain and where the settings
contain attribute names. The latter should cover most of your needs,
while for more complicated widgets you will need to derive a new
classes from it. There may even be some cases in which the context is
not defined by the domain, in which case the
<tt class="xref py py-class docutils literal"><span class="pre">ContextHandler</span></tt> will be used as a base for your new
handler.</p>
<p>Contexts need to be declared, opened and closed. Opening and
closing usually takes place (in the opposite order) in the function
that handles the data signal. This is how it looks in the scatter plot
(the code is somewhat simplified for clarity).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">cdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">closeContext</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">insideColors</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">clusterClosure</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initAttrValues</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">openContext</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">updateGraph</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sendSelections</span><span class="p">()</span>
</pre></div>
</div>
<p>In general, the function should go like this.</p>
<ul class="simple">
<li>Do any clean-up you need, but without clearing any of the settings that need
to be saved. Scatter plot needs none.</li>
<li>Call <tt class="xref py py-obj docutils literal"><span class="pre">self.closeContext()</span></tt>; this ensures that all the context dependent
settings (e.g. attribute names from the list boxes) are remembered.</li>
<li>Get the data (or whatever you do) and set the controls to some defaults as
if there were no context retrieving mechanism. Scatter plot does it by
calling <tt class="xref py py-obj docutils literal"><span class="pre">initAttrValues()</span></tt> which assigns the first two attributes to
the x and y axis and the class attribute to the color. At this phase, you
shouldn&#8217;t call any functions that depend on the settings, such as drawing
the graph.</li>
<li>Call <tt class="xref py py-obj docutils literal"><span class="pre">self.openContext</span></tt> (more about the arguments later). This will
search for a suitable context and assign the controls new values if one is
found. If there is no saved context that can be used, a new context is
created and filled with the default values that were assigned at the previous
point.</li>
<li>Finally, adjust the widget according to the retrieved controls. Scatter plot
now plots the graph by calling <tt class="xref py py-obj docutils literal"><span class="pre">updateGraph</span></tt>.</li>
</ul>
<p><tt class="xref py py-obj docutils literal"><span class="pre">closeContext</span></tt> has an argument, the name of the context. If omitted
(like above), the default name (<tt class="xref py py-obj docutils literal"><span class="pre">&quot;&quot;</span></tt>) is used. When opening the context,
we give the name and some arguments on which the context depends. In case of
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt>, which scatter plot uses, we can give it a domain
or any object that has a field <tt class="xref py py-obj docutils literal"><span class="pre">domain</span></tt> containing a domain. Whether a
saved context can be reused is judged upon the presence of attributes in the
domain.</p>
<p>If the widget is constructed appropriately (that is, if it strictly uses OWGUI
controls instead of the Qt&#8217;s), no other administration is needed to switch the
context.</p>
<p>Except for declaring the context settings, that is. Scatter plot has this just
below the <tt class="xref py py-obj docutils literal"><span class="pre">settingsList</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">contextHandlers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">DomainContextHandler</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span>
  <span class="p">[(</span><span class="s">&quot;attrX&quot;</span><span class="p">,</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Required</span><span class="p">),</span>
   <span class="p">(</span><span class="s">&quot;attrY&quot;</span><span class="p">,</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Required</span><span class="p">),</span>
   <span class="p">(</span><span class="s">&quot;attrLabel&quot;</span><span class="p">,</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Optional</span><span class="p">),</span>
   <span class="p">(</span><span class="s">&quot;attrShape&quot;</span><span class="p">,</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Optional</span><span class="p">),</span>
   <span class="p">(</span><span class="s">&quot;attrSize&quot;</span><span class="p">,</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Optional</span><span class="p">)])}</span>
</pre></div>
</div>
<p><tt class="xref py py-obj docutils literal"><span class="pre">contextHandlers</span></tt> is a dictionary whose keys are contexts&#8217; names. Each
widget can have multiple contexts; for an unrealistic example, consider a
scatter plot which gets two data sets and uses one attribute from the first
for the x axis, and an attribute from the other for y. Since we won&#8217;t see this
often, the default name for a context is an empty string.</p>
<p>The values in the dictionary are context handlers. Scatter plot declares that
it has a DomainContextHandler with name &#8220;&#8221; (sorry for the repetition) with
attributes &#8220;attrX&#8221;, &#8220;attrY&#8221;, &#8220;attrLabel&#8221;, &#8220;attrShape&#8221; and &#8220;attrSize&#8221;. The
first two are required, while the other three are optional.</p>
</div>
<div class="section" id="using-domaincontexthandler">
<h2>Using <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt><a class="headerlink" href="#using-domaincontexthandler" title="Permalink to this headline">¶</a></h2>
<p>What we said above is not exactly true. <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.Required</span></tt>
is the default flag, so <tt class="xref py py-obj docutils literal"><span class="pre">(&quot;attrX&quot;,</span> <span class="pre">DomainContextHandler.Required)</span></tt> can
be replaced by simply <tt class="xref py py-obj docutils literal"><span class="pre">&quot;attrX&quot;</span></tt>. And the latter three have the
same flags, so they can be grouped into <tt class="xref py py-obj docutils literal"><span class="pre">([&quot;attrLabel&quot;,</span>
<span class="pre">&quot;attrShape&quot;,</span> <span class="pre">&quot;attrSize&quot;],</span> <span class="pre">DomainContextHandler.Optional)</span></tt>. So
what scatter plot really says is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">contextHandlers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">DomainContextHandler</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[</span>
   <span class="s">&quot;attrX&quot;</span><span class="p">,</span> <span class="s">&quot;attrY&quot;</span><span class="p">,</span>
   <span class="p">([</span><span class="s">&quot;attrLabel&quot;</span><span class="p">,</span> <span class="s">&quot;attrShape&quot;</span><span class="p">,</span> <span class="s">&quot;attrSize&quot;</span><span class="p">],</span> <span class="n">DomainContextHandler</span><span class="o">.</span><span class="n">Optional</span><span class="p">)])}</span>
</pre></div>
</div>
<p>What do <tt class="docutils literal"><span class="pre">Optional</span></tt> and <tt class="docutils literal"><span class="pre">Required</span></tt> mean? Say that you used the
scatter plot on the data with attributes A, B, C and D; A and B are
used for the x and y axis and D defined the colors of examples. Now
you load a new data with attributes A, B, E, and F. The same context
can be used - A and B will again be shown on x and y axis and the
default (the one set by <tt class="xref py py-obj docutils literal"><span class="pre">self.initAttrValues</span></tt>) will be used
for the color since the attribute D is missing in the new data. Now
comes the third data set, which only has attributes A, D and E. The
context now can&#8217;t be reused since the attribute used for the
<em>required</em> <tt class="xref py py-obj docutils literal"><span class="pre">attrY</span></tt> (the y axis) is missing.</p>
<p>OK, now it is time to be a bit formal. As said,
<tt class="xref py py-obj docutils literal"><span class="pre">contextHandlers</span></tt> is a dictionary and the values in it need
to be context handlers derived from the abstract class
<tt class="xref py py-obj docutils literal"><span class="pre">ContextHandler</span></tt>. The way it is declared of course depends
upon its constructor, so the above applies only to the usual
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt>.</p>
<p><tt class="xref py py-class docutils literal"><span class="pre">DomainContextHandler</span></tt>&#8216;s constructor has the following arguments</p>
<dl class="docutils">
<dt><cite>contextName</cite></dt>
<dd>The name of the context; it should consist of letters and digits (it is
used as a part of a variable name). In case the widget has multiple
contexts, they should have unique names. In most cases there will be only
one context, so you can leave it empty.</dd>
<dt><cite>fields</cite></dt>
<dd>The names of the attributes to be saved and the corresponding flags. They
are described in more details below.</dd>
<dt><cite>cloneIfImperfect</cite></dt>
<dd>States that when the context doesn&#8217;t match perfectly, that is, unless the
domain is exactly the same as the domain from which the context was
originally created, <tt class="xref py py-obj docutils literal"><span class="pre">openContext</span></tt> shouldn&#8217;t reuse a context but create
a copy of the best matching context instead. Default is <a class="reference external" href="http://docs.python.org/library/constants.html#True" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">True</span></tt></a>.</dd>
<dt><cite>loadImperfect</cite></dt>
<dd>tells whether the contexts that do not match perfectly (see above) should
be used or not. Default is <a class="reference external" href="http://docs.python.org/library/constants.html#True" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">True</span></tt></a>.</dd>
<dt><cite>findImperfect</cite></dt>
<dd>Tells whether imperfect contexts match at all or not (this flag is
somewhat confused with <tt class="xref py py-obj docutils literal"><span class="pre">loadImperfect</span></tt>, but it may come useful some
day). Default is <a class="reference external" href="http://docs.python.org/library/constants.html#True" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">True</span></tt></a> again.</dd>
<dt><cite>syncWithGlobal</cite></dt>
<dd>Tells whether instances of this widget should have a shared list of
contexts (default). The alternative is that each keeps its own list;
each individual list is merged with the global when the widget is deleted
from the canvas (or when the canvas is closed). This setting only applies
to canvas, while in saved applications widgets always have separate settings
lists.</dd>
<dt><cite>maxAttributesToPickle</cite></dt>
<dd>To keep the size of the context file small, settings for domains exceeding
a certain number of attributes are not pickled. Default is 100, but you can
increase (or decrease this) if you need to.</dd>
</dl>
<p>The truly interesting argument is <tt class="xref py py-obj docutils literal"><span class="pre">fields</span></tt>. It roughly corresponds to the
<tt class="xref py py-obj docutils literal"><span class="pre">settingsList</span></tt> in that each element specifies one widget attribute to be
saved. The elements of <tt class="xref py py-obj docutils literal"><span class="pre">fields</span></tt> can be strings, tuples and/or instances of
<tt class="xref py py-obj docutils literal"><span class="pre">ContextField</span></tt> (whatever you give, it gets automatically converted to the
latter). When given as tuples, they should consist of two elements, the field
name (just like in <tt class="xref py py-obj docutils literal"><span class="pre">settingsList</span></tt>) and a flag. Here are the possible flags:</p>
<ul class="simple">
<li><tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.Optional</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.SelectedRequired</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.Required</span></tt> state whether the attribute is optional
or required, as explained above. Default is <tt class="xref py py-obj docutils literal"><span class="pre">Required</span></tt>.
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.SelectedRequired</span></tt> is applicable only if the
control is a list box, where it means that the attributes that are selected
are required while the other attributes from the list are not.</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.NotAttribute</span></tt> the setting is not an attribute
name. You can essentially make a check box context dependent, but we very
strongly dissuade from this since it can really confuse the user if some
check boxes change with the data while most do not.</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.List</span></tt> tells that the attribute corresponds to a
list box.</li>
</ul>
<p>Flags can be combined, so to specify a list in which all attributes
are required, you would give <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.List</span> <span class="pre">+</span>
<span class="pre">DomainContextHandler.Required</span></tt>. Since this combination is
common, <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.RequiredList</span></tt> can be used
instead.</p>
<p>There are two shortcuts. The default flag is
<tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler.Required</span></tt>. If your attribute is like
this (as most are), you can give only its name instead of a
tuple. This is how <tt class="xref py py-obj docutils literal"><span class="pre">&quot;attrX&quot;</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">&quot;attrY&quot;</span></tt> are
given in the scatter plot. If there are multiple attributes with the
same flags, you can specify them with a tuple in which the first
element is not a string but a list of strings. We have seen this trick
in the scatter plot, too.</p>
<p>But the tuples are actually a shortcut for instances of
<tt class="xref py py-obj docutils literal"><span class="pre">ContextField</span></tt>. When you say <tt class="xref py py-obj docutils literal"><span class="pre">&quot;attrX&quot;</span></tt> this is actually
<tt class="xref py py-obj docutils literal"><span class="pre">ContextField(&quot;attrX&quot;,</span> <span class="pre">DomainContextHandler.Required)</span></tt></p>
</div>
<div class="section" id="defining-new-context-handlers">
<h2>Defining New Context Handlers<a class="headerlink" href="#defining-new-context-handlers" title="Permalink to this headline">¶</a></h2>
<p>Avoid it if you can. If you can&#8217;t, here&#8217;s the list of the methods you may need
to implement. You may want to copy as much from the <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt>
as you can.</p>
<dl class="docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">__init__</span></tt></dt>
<dd>Has the same arguments as the <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt>&#8216;s, except for the
<tt class="xref py py-obj docutils literal"><span class="pre">fields</span></tt>.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">newContext()</span></tt></dt>
<dd>Creates and returns a new context. In <tt class="xref py py-obj docutils literal"><span class="pre">ContextHandler</span></tt> it returns an
instance of <tt class="xref py py-obj docutils literal"><span class="pre">Context</span></tt>; you probably won&#8217;t need to change this.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">openContext(widget,</span> <span class="pre">*args)</span></tt></dt>
<dd><p class="first">The method is given a widget and some additional arguments based on which
the contexts are compared. In case of <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt> this is
a domain. There can be one or more such arguments. Note that the method
<tt class="xref py py-obj docutils literal"><span class="pre">openContext</span></tt> which we talked about above is a method of
<tt class="xref py py-obj docutils literal"><span class="pre">OWBaseWidget</span></tt>, while here we describe a method of context handlers.
Actually, <tt class="xref py py-obj docutils literal"><span class="pre">OWBaseWidget.openContext(self,contextName,</span> <span class="pre">*args)</span></tt> calls
the context handler&#8217;s, passing it&#8217;s <tt class="xref py py-obj docutils literal"><span class="pre">self</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">*args</span></tt>.</p>
<p class="last">It needs to find a matching context and copy its settings to the widget or
construct a new context and copy the settings from the widget. Also, when an
old context is reused, it should be moved to the beginning of the list.
<tt class="xref py py-obj docutils literal"><span class="pre">ContextHandler</span></tt> already defines this method, which should usually
suffice. <tt class="xref py py-obj docutils literal"><span class="pre">DomainContextHandler</span></tt> adds very little to it.</p>
</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">closeContext</span></tt></dt>
<dd>Copies the settings from the widget by calling <tt class="xref py py-obj docutils literal"><span class="pre">settingsFromWidget</span></tt>.
You probably won&#8217;t need to overwrite it.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">match</span></tt></dt>
<dd>The method is called by <tt class="xref py py-obj docutils literal"><span class="pre">openContext</span></tt> to find a matching context.
Given an existing context and the arguments that were given to
<tt class="xref py py-obj docutils literal"><span class="pre">openContext</span></tt> (for instance, a domain), it should decide whether the
context matches or not. If it returns 2, it is a perfect match (e.g.
domains are the same). If it returns 0, the context is not applicable
(e.g. some of the required attributes are missing). In case it returns a
number between 0 and 1 (excluding 0), the higher the number the better the
match. <tt class="xref py py-obj docutils literal"><span class="pre">openContext</span></tt> will use the best matching context (or the
perfect one, if found).</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">settingsToWidget</span></tt> / <tt class="xref py py-obj docutils literal"><span class="pre">settingsFromWidget</span></tt></dt>
<dd>Copy the settings to and from the widget.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">fastSave</span></tt></dt>
<dd>This function is called by the widget&#8217;s <tt class="xref py py-obj docutils literal"><span class="pre">__setattr__</span></tt> each time any
widget&#8217;s variable is changed to immediately synchronize the context with
the state of the widget. The method is really needed only when
<tt class="xref py py-obj docutils literal"><span class="pre">syncWithGlobal</span></tt> is set. When the context is closed,
<tt class="xref py py-obj docutils literal"><span class="pre">closeContext</span></tt> will save the settings anyway.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">cloneContext</span></tt></dt>
<dd>Given an existing context, it prepares and returns a copy. The method is
optional; <a class="reference external" href="http://docs.python.org/library/copy.html#copy.deepcopy" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">copy.deepcopy</span></tt></a> can be used instead.</dd>
</dl>
</div>
<div class="section" id="saving-and-loading-settings">
<h2>Saving and loading settings<a class="headerlink" href="#saving-and-loading-settings" title="Permalink to this headline">¶</a></h2>
<p>Settings can be saved in two different places. Orange Canvas save
settings in .ini files in its application data directory. Each widget type has
a separate file; for instance, the scatter plot&#8217;s settings are saved in
<tt class="xref py py-obj docutils literal"><span class="pre">ScatterPlot.ini</span></tt>. Saved schemas and applications save
settings in .sav files; the .sav file is placed in the same directory
as the schema or application, has the same name (except for the
extension) and contains the settings for all widgets in the
schema/application.</p>
<p>Saving and loading is done automatically by canvas or the
application. In a very rare case you need it to run these operations
manually, the functions involved are <tt class="xref py py-obj docutils literal"><span class="pre">loadSettings(self,</span> <span class="pre">file=None)</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">saveSettings(self,</span> <span class="pre">file=None)</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">loadSettingsStr(self,</span> <span class="pre">str)</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">saveSettingsStr(self)</span></tt>. The first two load and save from
the file; if not given, the default name (widget&#8217;s name +
<tt class="xref py py-obj docutils literal"><span class="pre">ini</span></tt>) is used. They are called by the canvas, never by a
schema or an application. The last two load and save from a string and
are used by schemas and applications. All the functions are defined as
methods of <tt class="xref py py-obj docutils literal"><span class="pre">OWBaseWidget</span></tt>, which all other widgets are
derived from.</p>
</div>
</div>



          </div>
        </div>
      </div> 
      <div class="clearer"></div>
    </div>  
	
    <div class="footer">
    </div>
	            </div>
        </div>
        <div class="border1"></div>
        <div class="border2"></div>
    </div>
</div>

  </body>
</html>