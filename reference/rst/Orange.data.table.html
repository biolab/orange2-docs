
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Data table (Table) &mdash; Orange Documentation v2.7.8</title>
    
    <link rel="stylesheet" href="../../_static/orange.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.7.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Orange Documentation v2.7.8" href="../../index.html" />
    <script type="text/javascript" src="../../_static/copybutton.js"></script>

  </head>
  <body>
	<div id="container">
    <div class="border1"></div>
    <div class="border2"></div>
    <div class="borderv">
        <div id="header">
			<div id="orangeimg"><h1><a href="http://orange.biolab.si"><img src="../../_static/orange-logo-w.png" alt="Orange" /></a></h1></div>

            <div id="cse-search-box" style="height: 22px;"></div>
            <div id="underimg"></div>
        </div>
    </div>
    <div class="border2"></div>
    <div class="border1"></div>

    <div id="main">
        <div class="border1"></div>
        <div class="border2"></div>
        <div class="borderv">
            <div id="maininner">
            <p style="font-size: 32px;">
                This is documentation for Orange 2.7. For the latest documentation, 
                <a href="http://orange.biolab.si/docs">
                see Orange 3</a>.
            </p>
 

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
    <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
           <p><a class="uplink" href="../../index.html">Orange Documentation v2.7.8</a></p>
           <ul>
<li><a class="reference internal" href="#">Data table (<tt class="docutils literal"><span class="pre">Table</span></tt>)</a></li>
</ul>

        </div>
    </div>
    
  <div class="section" id="data-table-table">
<h1>Data table (<tt class="docutils literal"><span class="pre">Table</span></tt>)<a class="headerlink" href="#data-table-table" title="Permalink to this headline">¶</a></h1>
<p>Class <cite>Orange.data.Table</cite> holds a list of data instances of type
<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Instance</span></tt></a>. All instances belong to the same domain
(<a class="reference internal" href="Orange.data.domain.html#Orange.data.Domain" title="Orange.data.Domain"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Domain</span></tt></a>).</p>
<p>Data tables are usually loaded from a file (see <a class="reference internal" href="Orange.data.formats.html#orange-data-formats"><em>Loading and saving data</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;titanic&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Data tables can also be created programmatically, as in the <a class="reference internal" href="#example-table-prog1"><em>code
below</em></a>.</p>
<p><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a> supports most list-like operations: getting, setting,
removing data instances, as well as methods <tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">extend</span></tt>. When setting items, the item must be
either the instance of the correct type or a Python list of
appropriate length and content to be converted into a data instance of
the corresponding domain. Retrieving data instances returns references
and not copies: changing the retrieved instance changes the data in the
table. Slicing returns ordinary Python lists containing references to
data instances, not a new <a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a>.</p>
<p>According to a Python convention, the data table is considered <tt class="docutils literal"><span class="pre">False</span></tt>
when empty.</p>
<dl class="class">
<dt id="Orange.data.Table">
<em class="property">class </em><tt class="descclassname">Orange.data.</tt><tt class="descname">Table</tt><a class="headerlink" href="#Orange.data.Table" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="Orange.data.Table.domain">
<tt class="descname">domain</tt><a class="headerlink" href="#Orange.data.Table.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The domain to which the instances belong. This
attribute is read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.owns_instances">
<tt class="descname">owns_instances</tt><a class="headerlink" href="#Orange.data.Table.owns_instances" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if the table contains the data instances and <tt class="docutils literal"><span class="pre">False</span></tt> if
it contains references to instances owned by another table.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.owner">
<tt class="descname">owner</tt><a class="headerlink" href="#Orange.data.Table.owner" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual owner of the data when <tt class="docutils literal"><span class="pre">own_instances</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>;
<tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.version">
<tt class="descname">version</tt><a class="headerlink" href="#Orange.data.Table.version" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer that is increased when instances are added or
removed from the table. It does not detect changes of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.random_generator">
<tt class="descname">random_generator</tt><a class="headerlink" href="#Orange.data.Table.random_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Random generator that is used by method
<a class="reference internal" href="#Orange.data.Table.random_instance" title="Orange.data.Table.random_instance"><tt class="xref py py-obj docutils literal"><span class="pre">random_instance</span></tt></a>. If the method is called and
<tt class="docutils literal"><span class="pre">random_generator</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, a new generator is constructed
with random seed 0 and stored here for future use.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.attribute_load_status">
<tt class="descname">attribute_load_status</tt><a class="headerlink" href="#Orange.data.Table.attribute_load_status" title="Permalink to this definition">¶</a></dt>
<dd><p>If the table was loaded from a file, this list of flags tells
whether the feature descriptors were reused and how they
matched. See <a class="reference internal" href="Orange.feature.descriptor.html#variable-descriptor-reuse"><em>descriptor reuse</em></a>
for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.data.Table.meta_attribute_load_status">
<tt class="descname">meta_attribute_load_status</tt><a class="headerlink" href="#Orange.data.Table.meta_attribute_load_status" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary holding this same information for meta
attributes, with keys corresponding to their ids and values to
load statuses.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.__init__">
<tt class="descname">__init__</tt><big>(</big><em>filename</em><span class="optional">[</span>, <em>create_new_on</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the given file. If the name includes the
extension it must be one of the known file formats
(see <a class="reference internal" href="Orange.data.formats.html#orange-data-formats"><em>Loading and saving data</em></a>). If no extension is given, the
directory is searched for any file with recognized extensions. If the
file is not found, Orange will also search the directories
specified in the environment variable <cite>ORANGE_DATA_PATH</cite>.</p>
<p>The optional flag <tt class="docutils literal"><span class="pre">create_new_on</span></tt> decides when variable
descriptors are reused. See <a class="reference internal" href="Orange.feature.descriptor.html#variable-descriptor-reuse"><em>descriptor reuse</em></a> for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; the name of the file</li>
<li><strong>create_new_on</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; flag specifying when to reuse existing descriptors</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="example-table-prog1"></span><dl class="method">
<dt>
<tt class="descname">__init__</tt><big>(</big><em>domain</em><big>)</big></dt>
<dd><p>Construct an empty data table with the given domain.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;4&quot;</span><span class="p">]</span>

<span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Discrete</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">[:</span><span class="n">card</span><span class="p">])</span>
              <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="s">&quot;abcdef&quot;</span><span class="p">,</span> <span class="n">cards</span><span class="p">)]</span>
<span class="n">classattr</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Discrete</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;0&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">])</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Domain</span><span class="p">(</span><span class="n">features</span> <span class="o">+</span> <span class="p">[</span><span class="n">classattr</span><span class="p">])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
</pre></div>
</div>
<p>The example <a class="reference internal" href="#example-table-prog2"><em>continues</em></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> (<a class="reference internal" href="Orange.data.domain.html#Orange.data.Domain" title="Orange.data.Domain"><em>Orange.data.Domain</em></a>) &#8211; domain descriptor</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">__init__</tt><big>(</big><em>instances</em><span class="optional">[</span>, <em>references</em><span class="optional">]</span><big>)</big></dt>
<dd><p>Construct a new data table containing the given data
instances. These can be given either as another <a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a>
or as list of instances represented by list of value or as
<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Instance</span></tt></a>.</p>
<p>If the optional second argument is <tt class="docutils literal"><span class="pre">True</span></tt>, the first argument
must be a <a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a>. The new table will contain references
to data stored in the given table. If the second argument is
omitted or <tt class="docutils literal"><span class="pre">False</span></tt>, data instances are copied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>instances</strong> (<em>Table or list</em>) &#8211; data instances</li>
<li><strong>references</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if <tt class="docutils literal"><span class="pre">True</span></tt>, the new table contains references</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="example-table-prog2"></span><dl class="method">
<dt>
<tt class="descname">__init__</tt><big>(</big><em>domain</em>, <em>instances</em><big>)</big></dt>
<dd><p>Construct a new data table with the given domain and initialize
it with the given instances. Instances can be given as a
<a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a> (if domains do not match, they are converted),
as a list containing either instances of
<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Instance</span></tt></a> or lists.</p>
<p>This constructor can also be used for conversion from numpy
arrays. The argument <tt class="docutils literal"><span class="pre">instances</span></tt> can be a numpy array. The number
of variables in the domain must match the number of columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<a class="reference internal" href="Orange.data.domain.html#Orange.data.Domain" title="Orange.data.Domain"><em>Orange.data.Domain</em></a>) &#8211; domain descriptor</li>
<li><strong>instances</strong> (<em>Table or list or numpy.array</em>) &#8211; data instances</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following example fills the data table created <a class="reference internal" href="#example-table-prog1"><em>above</em></a> with some data from a list.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">loe</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">],</span>
       <span class="p">[</span><span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;0&quot;</span><span class="p">],</span>
       <span class="p">[</span><span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">]</span>
      <span class="p">]</span>

<span class="n">d2</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">loe</span><span class="p">)</span>
</pre></div>
</div>
<p>The following example shows initializing a data table from
numpy array.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Domain</span><span class="p">([</span><span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Continuous</span><span class="p">(</span><span class="s">&#39;a</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">__init__</tt><big>(</big><em>tables</em><big>)</big></dt>
<dd><p>Construct a table by combining data instances from a list of
tables. All tables must have the same length. Domains are
combined so that each (ordinary) feature appears only once in
the resulting table. The class attribute is the last class
attribute in the list of tables, while all other class attributes
are added as ordinary features. For instance, if three tables
are merged but the last one is class-less, the class attribute
for the new table will come from the second table. Meta
attributes for the new domain are merged based on id&#8217;s: if the
same attribute appears under two id&#8217;s it will be added
twice. If, on the opposite, same id appears two different
attributes in two tables, this raises an exception. As
instances are merged, exception is raised if a features or
a meta attribute that appears in multiple tables does not have the
same value on all of them; the feature is allowed to have a
missing value on one or more (or all) tables.</p>
<p>Note that this is not the SQL&#8217;s join operator as it doesn&#8217;t
try to find matches between the tables but instead merges them
row by row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tables</strong> (list of instances of <a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a>) &#8211; tables to be merged into the new table</td>
</tr>
</tbody>
</table>
<p>For example, suppose the file merge1.tab contains:</p>
<div class="highlight-python"><pre>a1    a2    m1    m2
f     f     f     f
            meta  meta
1     2     3     4
5     6     7     8
9     10    11    12</pre>
</div>
<p>and merge2.tab contains:</p>
<div class="highlight-python"><pre>a1    a3    m1     m3
f     f     f      f
            meta   meta
1     2.5   3      4.5
5     6.5   7      8.5
9     10.5  11     12.5</pre>
</div>
<p>The two tables can be loaded, merged and printed out by the
following script.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">data1</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;merge1.tab&quot;</span><span class="p">)</span>
<span class="n">data2</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;merge2.tab&quot;</span><span class="p">)</span>

<span class="n">merged</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">([</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">])</span>

<span class="k">print</span> <span class="s">&quot;Domain 1: &quot;</span><span class="p">,</span> <span class="n">data1</span><span class="o">.</span><span class="n">domain</span>
<span class="k">print</span> <span class="s">&quot;Domain 2: &quot;</span><span class="p">,</span> <span class="n">data2</span><span class="o">.</span><span class="n">domain</span>
<span class="k">print</span> <span class="s">&quot;Merged:   &quot;</span><span class="p">,</span> <span class="n">merged</span><span class="o">.</span><span class="n">domain</span>
<span class="k">print</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">)):</span>
    <span class="k">print</span> <span class="s">&quot;  &quot;</span><span class="p">,</span> <span class="n">data1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot; +&quot;</span><span class="p">,</span> <span class="n">data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">merged</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span>
</pre></div>
</div>
<p>This is what the output looks like:</p>
<div class="highlight-python"><pre>Domain 1:  [a1, a2], {-2:m1, -3:m2}
Domain 2:  [a1, a3], {-2:m1, -4:m3}
Merged:    [a1, a2, a3], {-2:m1, -3:m2, -4:m3}

   [1, 2], {"m1":3, "m2":4}
 + [1, 2.5], {"m1":3, "m3":4.5}
-&gt; [1, 2, 2.5], {"m1":3, "m2":4, "m3":4.5}

   [5, 6], {
"m1":7, "m2":8}
 + [5, 6.5], {"m1":7, "m3":8.5}
-&gt; [5, 6, 6.5], {"m1":7, "m2":8, "m3":8.5}

   [9, 10], {"m1":11, "m2":12}
 + [9, 10.5], {"m1":11, "m3":12.5}
-&gt; [9, 10, 10.5], {"m1":11, "m2":12, "m3":12.5}</pre>
</div>
<p>Merging succeeds since the values of <cite>a1</cite> and <cite>m1</cite> are the
same for all matching instances from both tables.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.append">
<tt class="descname">append</tt><big>(</big><em>instance</em><big>)</big><a class="headerlink" href="#Orange.data.Table.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append the given instance to the end of the table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instance</strong> (<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Instance</span></tt></a> or a list) &#8211; instance to be appended</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">]</span>
    <span class="n">inst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">inst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">inst</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.extend">
<tt class="descname">extend</tt><big>(</big><em>instances</em><big>)</big><a class="headerlink" href="#Orange.data.Table.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Append the given list of instances to the end of the table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>instances</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; instances to be appended</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.select">
<tt class="descname">select</tt><big>(</big><em>folds</em><span class="optional">[</span>, <em>select</em>, <em>negate=False</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of instances as a new <a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a>. The first
argument should be a list of the same length as the table; its
elements should be integers or bools. The resulting table
contains instances corresponding to non-zero elements of the
list.</p>
<p>If the second argument is given, it must be an integer; method
<tt class="docutils literal"><span class="pre">select</span></tt> will then return the data instances for which the
corresponding <tt class="docutils literal"><span class="pre">fold</span></tt>&#8216;s elements match the value of the
argument <tt class="docutils literal"><span class="pre">select</span></tt>.</p>
<p>The third argument, <cite>negate</cite> inverts the selection. It can
only be given as a keyword.</p>
<p>Note: This method should be used when the selected data
instances are going to be modified later on. In all other
cases, method <a class="reference internal" href="#Orange.data.Table.select_ref" title="Orange.data.Table.select_ref"><tt class="xref py py-obj docutils literal"><span class="pre">select_ref</span></tt></a> is preferred.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>folds</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of fold indices corresponding to data instances</li>
<li><strong>select</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; select which instances to pick</li>
<li><strong>negate</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; inverts the selection</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>One common use of this method is to split the data into
folds. A list for the first argument can be prepared using
<cite>Orange.data.sample.SubsetIndicesCV</cite>. The following example
prepares a simple data table and indices for four-fold cross
validation, and then selects the training and testing sets for
each fold.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">domain</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Domain</span><span class="p">([</span><span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Continuous</span><span class="p">()])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>

<span class="n">cv_indices</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">SubsetIndicesCV</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Indices: &quot;</span><span class="p">,</span> <span class="n">cv_indices</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

<span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">train</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">cv_indices</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">negate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">test</span>  <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">cv_indices</span><span class="p">,</span> <span class="n">fold</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Fold </span><span class="si">%d</span><span class="s">: train &quot;</span> <span class="o">%</span> <span class="n">fold</span>
    <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;    &quot;</span><span class="p">,</span> <span class="n">inst</span>
    <span class="k">print</span>
    <span class="k">print</span> <span class="s">&quot;      : test  &quot;</span>
    <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;    &quot;</span><span class="p">,</span> <span class="n">inst</span>
    <span class="k">print</span>
</pre></div>
</div>
<p>The printout begins with:</p>
<div class="highlight-python"><pre>Indices:  &lt;1, 0, 2, 2, 0, 1, 0, 3, 1, 3&gt;

Fold 0: train
     [0.000000]
     [2.000000]
     [3.000000]
     [5.000000]
     [7.000000]
     [8.000000]
     [9.000000]

      : test
     [1.000000]
     [4.000000]
     [6.000000]</pre>
</div>
<p>Another form of calling the method is to use a vector of
zero&#8217;s and one&#8217;s.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">inst</span>
</pre></div>
</div>
<p>This prints out:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mf">0.000000</span><span class="p">]</span>
<span class="p">[</span><span class="mf">1.000000</span><span class="p">]</span>
<span class="p">[</span><span class="mf">9.000000</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.select_ref">
<tt class="descname">select_ref</tt><big>(</big><em>folds</em><span class="optional">[</span>, <em>select</em>, <em>negate=False</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.select_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#Orange.data.Table.select" title="Orange.data.Table.select"><tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt></a>, except that the resulting table
contains references to data instances in the original table
instead of its own copy of data.</p>
<p>In most cases, this function is preferred over the former
since it consumes less memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>folds</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of fold indices corresponding to data instances</li>
<li><strong>select</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; select which instances to pick</li>
<li><strong>negate</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; inverts the selection</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.get_items">
<tt class="descname">get_items</tt><big>(</big><em>indices</em><big>)</big><a class="headerlink" href="#Orange.data.Table.get_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a table with data instances indicated by indices. For
instance, <cite>data.get_items([0, 1, 9])</cite> returns a table with
instances with indices 0, 1 and 9.</p>
<p>This function is useful when data is going to be modified. If
not, use <a class="reference internal" href="#Orange.data.Table.get_items_ref" title="Orange.data.Table.get_items_ref"><tt class="xref py py-obj docutils literal"><span class="pre">get_items_ref</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> (<em>list of int&#8217;s</em>) &#8211; indices of selected data instances</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.get_items_ref">
<tt class="descname">get_items_ref</tt><big>(</big><em>indices</em><big>)</big><a class="headerlink" href="#Orange.data.Table.get_items_ref" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Same as above, except that it returns a table with references
to data instances. This method is usually
preferred over the above one.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> (<em>list of int&#8217;s</em>) &#8211; indices of selected data instances</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.filter">
<tt class="descname">filter</tt><big>(</big><em>conditions</em><big>)</big><a class="headerlink" href="#Orange.data.Table.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a table with data instances matching the
criteria. These can be given in form of keyword arguments or a
dictionary; with the latter, additional keyword argument <tt class="docutils literal"><span class="pre">negate</span></tt>
can be given to reverse the selection.</p>
<p>Note that method <a class="reference internal" href="#Orange.data.Table.filter_ref" title="Orange.data.Table.filter_ref"><tt class="xref py py-obj docutils literal"><span class="pre">filter_ref</span></tt></a> is more memory efficient and
should be preferred when data is not going to be modified.</p>
<p>Young patients from the lenses data set can be selected by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">young</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="s">&quot;young&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>More than one value can be allowed and more than one attribute
checked. This selects all patients with age &#8220;young&#8221; or &#8220;psby&#8221; who
are astigmatic:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">young</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">age</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;young&quot;</span><span class="p">,</span> <span class="s">&quot;presbyopic&quot;</span><span class="p">],</span> <span class="n">astigm</span><span class="o">=</span><span class="s">&quot;y&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following has the same effect:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">young</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">({</span><span class="s">&quot;age&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;young&quot;</span><span class="p">,</span> <span class="s">&quot;presbyopic&quot;</span><span class="p">],</span>
                    <span class="s">&quot;astigm&quot;</span><span class="p">:</span> <span class="s">&quot;y&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>Selection can be reversed only in the latter form, by adding
a keyword argument <tt class="docutils literal"><span class="pre">negate</span></tt> with value 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">young</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">({</span><span class="s">&quot;age&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;young&quot;</span><span class="p">,</span> <span class="s">&quot;presbyopic&quot;</span><span class="p">],</span>
                    <span class="s">&quot;astigm&quot;</span><span class="p">:</span> <span class="s">&quot;y&quot;</span><span class="p">},</span>
                    <span class="n">negate</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Filters for continuous features are specified by pairs of
values. In dataset &#8220;bridges&#8221;, bridges with lengths between
1000 and 2000 (inclusive) are selected by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">LENGTH</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">))</span>
</pre></div>
</div>
<p>Bridges that are shorter or longer than that can be selected
by inverting the range.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mid</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">LENGTH</span><span class="o">=</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">filter</tt><big>(</big><em>filt</em><big>)</big></dt>
<dd><p>Similar to above, except that conditions are given as
<tt class="xref py py-obj docutils literal"><span class="pre">Orange.core.Filter</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.filter_ref">
<tt class="descname">filter_ref</tt><big>(</big><em>conditions)</em>, <em>filter_ref(filter</em><big>)</big><a class="headerlink" href="#Orange.data.Table.filter_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as the above two, except that they return a table
with references to instances instead of their copies.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.filter_bool">
<tt class="descname">filter_bool</tt><big>(</big><em>conditions)</em>, <em>filter_bool(filter</em><big>)</big><a class="headerlink" href="#Orange.data.Table.filter_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of bools denoting which data instances are
accepted by the conditions or the filter.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.translate">
<tt class="descname">translate</tt><big>(</big><em>domain</em><big>)</big><a class="headerlink" href="#Orange.data.Table.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new data table in which data instances are
translated into the given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> (<a class="reference internal" href="Orange.data.domain.html#Orange.data.Domain" title="Orange.data.Domain"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Domain</span></tt></a>) &#8211; new domain</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">translate</tt><big>(</big><em>variables</em><span class="optional">[</span>, <em>keep_metas</em><span class="optional">]</span><big>)</big></dt>
<dd><p>Similar to above, except that the domain is given by a
list of features. If <tt class="docutils literal"><span class="pre">keep_metas</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>, the new data
instances will also have all the meta attributes from the
original domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>variables</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; variables for the new data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.to_numpy">
<tt class="descname">to_numpy</tt><big>(</big><em>content</em>, <em>weightID</em>, <em>multinominal</em><big>)</big><a class="headerlink" href="#Orange.data.Table.to_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a data table to numpy array. Raises an exception if the data
contains undefined values. <a class="reference internal" href="#Orange.data.Table.to_numpyMA" title="Orange.data.Table.to_numpyMA"><tt class="xref py py-obj docutils literal"><span class="pre">to_numpyMA</span></tt></a> converts to a masked
array where the mask denotes the defined values. (For conversion
from numpy, see the constructor.)</p>
<p>The function returns a tuple with the array and, depending on
arguments, some vectors. The argument <tt class="docutils literal"><span class="pre">content</span></tt> is a string
separated in two parts with a slash. The part to the left of slash
describes the content of the array; in the part on the right side
lists the vectors. The content is described with the following
characters:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>features (without the class); can only appear on the left</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>like <tt class="docutils literal"><span class="pre">a</span></tt>, but raises exception if there are no features</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>class value represented as an index of the value (0, 1, 2...);
if the data has no class, the column is omitted (if <tt class="docutils literal"><span class="pre">c</span></tt> is to
the left of the slash) or the tuple will contain <tt class="docutils literal"><span class="pre">None</span></tt>
instead of the vector.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>like <tt class="docutils literal"><span class="pre">c</span></tt>, but raises exception if the data has no class</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd>like <tt class="docutils literal"><span class="pre">c</span></tt>, but one column for each target variable in a
multi-target domain.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>synonymous to <tt class="docutils literal"><span class="pre">m</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>instance weight; like for <tt class="docutils literal"><span class="pre">c</span></tt> the column is omitted or
<tt class="docutils literal"><span class="pre">None</span></tt> is returned instead of the vector if the argument
<tt class="docutils literal"><span class="pre">weightID</span></tt> is missing.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>instance weight; raise an exception if <tt class="docutils literal"><span class="pre">weightID</span></tt>
is missing.</dd>
<dt><tt class="docutils literal"><span class="pre">0</span></tt></dt>
<dd>a vector of zeros</dd>
<dt><tt class="docutils literal"><span class="pre">1</span></tt></dt>
<dd>a vector of ones</dd>
</dl>
<p>The default content is <tt class="docutils literal"><span class="pre">a/cw</span></tt>: an array with feature values and
separate vectors with classes and weights. Specifying an empty string
has the same effect. If the elements to the right of the slash repeat,
the function returns the same Python object, e.g. in <tt class="docutils literal"><span class="pre">acc000/cwww</span></tt> the
three weight vectors are one and the same Python object, so modifying
one will change all three of them.</p>
<p>This is the default behaviour on data set iris with 150 data
instances described by four features and a class value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">orange</span><span class="o">.</span><span class="n">ExampleTable</span><span class="p">(</span><span class="s">&quot;iris&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">toNumpy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(150, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(150,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([ 5.0999999 ,  3.5       ,  1.39999998,  0.2       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>For a more complicated example, the array will contain a column with
class, features, a vector of ones, two vectors with classes and
another vector of zeroes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">toNumpy</span><span class="p">(</span><span class="s">&quot;ca1cc0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([ 0., 5.0999999, 3.5       , 1.39999998, 0.2       , 1., 0., 0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">130</span><span class="p">]</span>
<span class="go">array([ 2., 7.4000001, 2.79999995, 6.0999999 , 1.89999998, 1., 2., 2., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="mi">120</span><span class="p">]</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>The third argument specifies the treatment of non-continuous
non-binary values (binary values are always translated to 0.0 or
1.0). The argument&#8217;s value can be
<tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table.Multinomial_Ignore</span></tt> (such features are
omitted), <tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table.Multinomial_AsOrdinal</span></tt> (the
values&#8217; indices are treated as continuous numbers) or
<tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table.Multinomial_Error</span></tt> (an exception is raised
if such features are encountered). Default treatment is
<tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table.ExampleTable.Multinomial_AsOrdinal</span></tt>.</p>
<p>When the class attribute is discrete and has more than two values,
an exception is raised unless multinomial attributes are treated as
ordinal. More options for treating multinominal values are available
in <tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.continuization</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.to_numpyMA">
<tt class="descname">to_numpyMA</tt><big>(</big><em>content</em>, <em>weightID</em>, <em>multinominal</em><big>)</big><a class="headerlink" href="#Orange.data.Table.to_numpyMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#Orange.data.Table.to_numpy" title="Orange.data.Table.to_numpy"><tt class="xref py py-obj docutils literal"><span class="pre">to_numpy</span></tt></a> except that it returns a masked array
with mask representing the (un)defined values.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.checksum">
<tt class="descname">checksum</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.data.Table.checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a CRC32 computed over all discrete and continuous
features and class attributes of all data instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.has_missing_values">
<tt class="descname">has_missing_values</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.data.Table.has_missing_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if any of data instances has any missing
values. Meta attributes are not checked.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.has_missing_classes">
<tt class="descname">has_missing_classes</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.data.Table.has_missing_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if any instance miss the class value.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.random_instance">
<tt class="descname">random_instance</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.data.Table.random_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random instance from the
table. Data table&#8217;s <a class="reference internal" href="#Orange.data.Table.random_generator" title="Orange.data.Table.random_generator"><tt class="xref py py-obj docutils literal"><span class="pre">random_generator</span></tt></a> is used,
which is initially seeded to 0, so results are
deterministic.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.remove_duplicates">
<tt class="descname">remove_duplicates</tt><big>(</big><span class="optional">[</span><em>weightID</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.remove_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove duplicates of data instances. If <tt class="docutils literal"><span class="pre">weightID</span></tt> is given,
a meta attribute is added which contains the number of
instances merged into each new instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>weightID</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; id for meta attribute with weight</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.sort">
<tt class="descname">sort</tt><big>(</big><span class="optional">[</span><em>variables</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the data table. The argument gives the
values ordered by importance. If omitted, the order from
the domain is used. Values of discrete
features are not ordered alphabetically but according to
the <a class="reference internal" href="Orange.feature.descriptor.html#Orange.feature.Discrete.values" title="Orange.feature.Discrete.values"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.feature.Discrete.values</span></tt></a>.</p>
<p>This sorts the data from the bridges data set by the lengths
and years of their construction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s">&quot;LENGTH&quot;</span><span class="p">,</span> <span class="s">&quot;ERECTED&quot;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.shuffle">
<tt class="descname">shuffle</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.data.Table.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly shuffle the data instances.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.add_meta_attribute">
<tt class="descname">add_meta_attribute</tt><big>(</big><em>attr</em><span class="optional">[</span>, <em>value=1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.data.Table.add_meta_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a meta value to all data instances. The first argument
can be an integer id, or a string or a variable descriptor
of a meta attribute registered in the domain.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.data.Table.remove_meta_attribute">
<tt class="descname">remove_meta_attribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#Orange.data.Table.remove_meta_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a meta attribute from all data instances.</p>
</dd></dl>

</dd></dl>

</div>



          </div>
        </div>
      </div> 
      <div class="clearer"></div>
    </div>  
	
    <div class="footer">
    </div>
	            </div>
        </div>
        <div class="border1"></div>
        <div class="border2"></div>
    </div>
</div>

  </body>
</html>