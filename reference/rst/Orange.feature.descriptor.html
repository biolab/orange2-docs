
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Descriptor &mdash; Orange Documentation v2.7.8</title>
    
    <link rel="stylesheet" href="../../_static/orange.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.7.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Orange Documentation v2.7.8" href="../../index.html" />
    <script type="text/javascript" src="../../_static/copybutton.js"></script>

  </head>
  <body>
	<div id="container">
    <div class="border1"></div>
    <div class="border2"></div>
    <div class="borderv">
        <div id="header">
			<div id="orangeimg"><h1><a href="http://orange.biolab.si"><img src="../../_static/orange-logo-w.png" alt="Orange" /></a></h1></div>

            <div id="cse-search-box" style="height: 22px;"></div>
            <div id="underimg"></div>
        </div>
    </div>
    <div class="border2"></div>
    <div class="border1"></div>

    <div id="main">
        <div class="border1"></div>
        <div class="border2"></div>
        <div class="borderv">
            <div id="maininner">
            <p style="font-size: 32px;">
                This is documentation for Orange 2.7. For the latest documentation, 
                <a href="http://orange.biolab.si/docs">
                see Orange 3</a>.
            </p>
 

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
    <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
           <p><a class="uplink" href="../../index.html">Orange Documentation v2.7.8</a></p>
           <ul>
<li><a class="reference internal" href="#">Descriptor</a><ul>
<li><a class="reference internal" href="#discrete-variables">Discrete variables</a></li>
<li><a class="reference internal" href="#continuous-variables">Continuous variables</a></li>
<li><a class="reference internal" href="#string-variables">String variables</a></li>
<li><a class="reference internal" href="#python-objects-as-variables">Python objects as variables</a></li>
<li><a class="reference internal" href="#storing-additional-attributes">Storing additional attributes</a></li>
<li><a class="reference internal" href="#reuse-of-descriptors">Reuse of descriptors</a></li>
<li><a class="reference internal" href="#variables-computed-from-other-variables">Variables computed from other variables</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
    
  <div class="section" id="descriptor">
<h1>Descriptor<a class="headerlink" href="#descriptor" title="Permalink to this headline">¶</a></h1>
<p>Data instances in Orange can contain several types of variables:
<a class="reference internal" href="#discrete"><em>discrete</em></a>, <a class="reference internal" href="#continuous"><em>continuous</em></a>,
<a class="reference internal" href="#string"><em>strings</em></a>, and <a class="reference internal" href="#python"><em>Python</em></a> and types derived
from it.  The latter represent arbitrary Python objects.  The names,
types, values (where applicable), functions for computing the variable
value from values of other variables, and other properties of the
variables are stored in descriptor classes derived from
<a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-obj docutils literal"><span class="pre">Descriptor</span></tt></a>.</p>
<p>Orange considers two variables (e.g. in two different data tables) the
same if they have the same descriptor. It is allowed - but not
recommended - to have different descriptors with the same name.</p>
<p>Descriptors can be constructed either by calling the corresponding
constructors or by a factory function <tt class="xref py py-func docutils literal"><span class="pre">make()</span></tt>, which either
retrieves an existing descriptor or constructs a new one.</p>
<dl class="class">
<dt id="Orange.feature.Descriptor">
<em class="property">class </em><tt class="descclassname">Orange.feature.</tt><tt class="descname">Descriptor</tt><a class="headerlink" href="#Orange.feature.Descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class for variable descriptors.</p>
<dl class="attribute">
<dt id="Orange.feature.Descriptor.name">
<tt class="descname">name</tt><a class="headerlink" href="#Orange.feature.Descriptor.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.var_type">
<tt class="descname">var_type</tt><a class="headerlink" href="#Orange.feature.Descriptor.var_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Variable type; it can be <tt class="xref py py-obj docutils literal"><span class="pre">Discrete</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">Continuous</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">String</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">Other</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.get_value_from">
<tt class="descname">get_value_from</tt><a class="headerlink" href="#Orange.feature.Descriptor.get_value_from" title="Permalink to this definition">¶</a></dt>
<dd><p>A function (an instance of
<a class="reference internal" href="Orange.classification.html#Orange.classification.Classifier" title="Orange.classification.Classifier"><tt class="xref py py-obj docutils literal"><span class="pre">Classifier</span></tt></a>) that computes a
value of the variable from values of one or more other
variables. This is used, for instance, in discretization,
which computes the value of a discretized variable from the
original continuous variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.ordered">
<tt class="descname">ordered</tt><a class="headerlink" href="#Orange.feature.Descriptor.ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag telling whether the values of a discrete variable are
ordered. At the moment, no built-in method treats ordinal
variables differently than nominal ones.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.random_generator">
<tt class="descname">random_generator</tt><a class="headerlink" href="#Orange.feature.Descriptor.random_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>A local random number generator used by method
<a class="reference internal" href="#Orange.feature.Descriptor.randomvalue" title="Orange.feature.Descriptor.randomvalue"><tt class="xref py py-obj docutils literal"><span class="pre">randomvalue()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.default_meta_id">
<tt class="descname">default_meta_id</tt><a class="headerlink" href="#Orange.feature.Descriptor.default_meta_id" title="Permalink to this definition">¶</a></dt>
<dd><p>A proposed (but not guaranteed) meta id to be used for that
variable.  For instance, when a tab-delimited contains meta
attributes and the existing variables are reused, they will
have this id (instead of a new one assigned by
<tt class="xref py py-obj docutils literal"><span class="pre">Orange.feature.Descriptor.new_meta_id()</span></tt>).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Descriptor.attributes">
<tt class="descname">attributes</tt><a class="headerlink" href="#Orange.feature.Descriptor.attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary which allows the user to store additional
information about the variable. All values should be
strings. See the section about <a class="reference internal" href="#attributes"><em>storing additional
information</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Descriptor.__call__">
<tt class="descname">__call__</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string, number, or other suitable object into a
variable value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj</strong> &#8211; An object to be converted into a variable value</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Descriptor.randomvalue">
<tt class="descname">randomvalue</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.randomvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random value for the variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Descriptor.compute_value">
<tt class="descname">compute_value</tt><big>(</big><em>instance</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.compute_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the variable given the instance by
calling obj:<cite>~Descriptor.get_value_from</cite> through a
mechanism that prevents infinite recursive calls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<div class="section" id="discrete-variables">
<h2>Discrete variables<a class="headerlink" href="#discrete-variables" title="Permalink to this headline">¶</a></h2>
<span class="target" id="discrete"></span><dl class="class">
<dt id="Orange.feature.Discrete">
<em class="property">class </em><tt class="descclassname">Orange.feature.</tt><tt class="descname">Discrete</tt><a class="headerlink" href="#Orange.feature.Discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a></p>
<p>Descriptor for discrete variables.</p>
<dl class="attribute">
<dt id="Orange.feature.Discrete.values">
<tt class="descname">values</tt><a class="headerlink" href="#Orange.feature.Discrete.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A list with symbolic names for variables&#8217; values. Values are stored as
indices referring to this list and modifying it instantly
changes the (symbolic) names of values as they are printed out or
referred to by user.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The size of the list is also used to indicate the number of
possible values for this variable. Changing the size - especially
shrinking the list - can crash Python. Also, do not add values
to the list by calling its append or extend method:
use <a class="reference internal" href="#Orange.feature.Discrete.add_value" title="Orange.feature.Discrete.add_value"><tt class="xref py py-obj docutils literal"><span class="pre">add_value</span></tt></a> method instead.</p>
<p class="last">It is also assumed that this attribute is always defined (but can
be empty), so never set it to <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Discrete.base_value">
<tt class="descname">base_value</tt><a class="headerlink" href="#Orange.feature.Discrete.base_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the base value for the variable as an index in <cite>values</cite>.
This can be, for instance, a &#8220;normal&#8221; value, such as &#8220;no
complications&#8221; as opposed to abnormal &#8220;low blood pressure&#8221;. The
base value is used by certain statistics, continuization etc.
potentially, learning algorithms. The default is -1 which means that
there is no base value.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Discrete.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#Orange.feature.Discrete.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a descriptor for variable with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Discrete.add_value">
<tt class="descname">add_value</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#Orange.feature.Discrete.add_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a value with symbolic name <tt class="docutils literal"><span class="pre">s</span></tt> to values. Always call
this function instead of appending to <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="continuous-variables">
<h2>Continuous variables<a class="headerlink" href="#continuous-variables" title="Permalink to this headline">¶</a></h2>
<span class="target" id="continuous"></span><dl class="class">
<dt id="Orange.feature.Continuous">
<em class="property">class </em><tt class="descclassname">Orange.feature.</tt><tt class="descname">Continuous</tt><a class="headerlink" href="#Orange.feature.Continuous" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a></p>
<p>Descriptor for continuous variables.</p>
<dl class="attribute">
<dt id="Orange.feature.Continuous.number_of_decimals">
<tt class="descname">number_of_decimals</tt><a class="headerlink" href="#Orange.feature.Continuous.number_of_decimals" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of decimals used when the value is printed out, converted to
a string or saved to a file.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Continuous.scientific_format">
<tt class="descname">scientific_format</tt><a class="headerlink" href="#Orange.feature.Continuous.scientific_format" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">True</span></tt>, the value is printed in scientific format whenever it
would have more than 5 digits. In this case, <a class="reference internal" href="#Orange.feature.Continuous.number_of_decimals" title="Orange.feature.Continuous.number_of_decimals"><tt class="xref py py-obj docutils literal"><span class="pre">number_of_decimals</span></tt></a> is
ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.feature.Continuous.adjust_decimals">
<tt class="descname">adjust_decimals</tt><a class="headerlink" href="#Orange.feature.Continuous.adjust_decimals" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells Orange to monitor the number of decimals when the value is
converted from a string (when the values are read from a file or
converted by, e.g. <tt class="docutils literal"><span class="pre">inst[0]=&quot;3.14&quot;</span></tt>):</p>
<ul class="simple">
<li>0: the number of decimals is not adjusted automatically;</li>
<li>1: the number of decimals is (and has already) been adjusted;</li>
<li>2: automatic adjustment is enabled, but no values have been
converted yet.</li>
</ul>
<p>By default, adjustment of the number of decimals goes as follows:</p>
<ul class="simple">
<li>If the variable was constructed when data was read from a file,
it will be printed with the same number of decimals as the
largest number of decimals encountered in the file. If
scientific notation occurs in the file,
<a class="reference internal" href="#Orange.feature.Continuous.scientific_format" title="Orange.feature.Continuous.scientific_format"><tt class="xref py py-obj docutils literal"><span class="pre">scientific_format</span></tt></a> will be set to <tt class="docutils literal"><span class="pre">True</span></tt> and scientific
format will be used for values too large or too small.</li>
<li>If the variable is created in a script, it will have,
by default, three decimal places. This can be changed either by
setting the value from a string (e.g. <tt class="docutils literal"><span class="pre">inst[0]=&quot;3.14&quot;</span></tt>,
but not <tt class="docutils literal"><span class="pre">inst[0]=3.14</span></tt>) or by manually setting the
<a class="reference internal" href="#Orange.feature.Continuous.number_of_decimals" title="Orange.feature.Continuous.number_of_decimals"><tt class="xref py py-obj docutils literal"><span class="pre">number_of_decimals</span></tt></a>.</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">start_value, end_value, step_value</tt></dt>
<dd><p>The range used for <tt class="xref py py-obj docutils literal"><span class="pre">randomvalue</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.feature.Continuous.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#Orange.feature.Continuous.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a descriptor for variable with the given name.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="string-variables">
<h2>String variables<a class="headerlink" href="#string-variables" title="Permalink to this headline">¶</a></h2>
<span class="target" id="string"></span><dl class="class">
<dt id="Orange.feature.String">
<em class="property">class </em><tt class="descclassname">Orange.feature.</tt><tt class="descname">String</tt><a class="headerlink" href="#Orange.feature.String" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a></p>
<p>Descriptor for variables that contain strings. No method can use them for
learning; some will raise error or warnings, and others will
silently ignore them. They can be, however, used as meta-attributes; if
instances in a dataset have unique IDs, the most efficient way to store them
is to read them as meta-attributes. In general, never use discrete
attributes with many (say, more than 50) values. Such attributes are
probably not of any use for learning and should be stored as string
attributes.</p>
<p>When converting strings into values and back, empty strings are treated
differently than usual. For other types, an empty string denotes
undefined values, while <a class="reference internal" href="#Orange.feature.String" title="Orange.feature.String"><tt class="xref py py-obj docutils literal"><span class="pre">String</span></tt></a> will take empty strings
as empty strings &#8211; except when loading or saving into file.
Empty strings in files are interpreted as undefined; to specify an empty
string, enclose the string in double quotes; these are removed when the
string is loaded.</p>
<dl class="method">
<dt id="Orange.feature.String.__init__">
<tt class="descname">__init__</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#Orange.feature.String.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a descriptor for variable with the given name.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="python-objects-as-variables">
<h2>Python objects as variables<a class="headerlink" href="#python-objects-as-variables" title="Permalink to this headline">¶</a></h2>
<span class="target" id="python"></span><dl class="class">
<dt id="Orange.feature.Python">
<em class="property">class </em><tt class="descclassname">Orange.feature.</tt><tt class="descname">Python</tt><a class="headerlink" href="#Orange.feature.Python" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a></p>
<p>Base class for descriptors defined in Python. It is fully functional
and can be used as a descriptor for attributes that contain arbitrary Python
values. Since this is an advanced topic, PythonVariables are described on a
separate page. !!TODO!!</p>
</dd></dl>

</div>
<div class="section" id="storing-additional-attributes">
<span id="attributes"></span><h2>Storing additional attributes<a class="headerlink" href="#storing-additional-attributes" title="Permalink to this headline">¶</a></h2>
<p>All variables have a field <a class="reference internal" href="#Orange.feature.Descriptor.attributes" title="Orange.feature.Descriptor.attributes"><tt class="xref py py-obj docutils literal"><span class="pre">attributes</span></tt></a>, a dictionary
that can store additional string data.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>
<span class="n">titanic</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;titanic.tab&quot;</span><span class="p">)</span>
<span class="n">var</span> <span class="o">=</span> <span class="n">titanic</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span> <span class="n">var</span>
<span class="k">print</span> <span class="s">&quot;Attributes&quot;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">attributes</span>
<span class="n">var</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;12&quot;</span>
<span class="k">print</span> <span class="s">&quot;Set a=12&quot;</span>
<span class="k">print</span> <span class="s">&quot;Attributes&quot;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">attributes</span>
</pre></div>
</div>
<p>These attributes can only be saved to a .tab file. They are listed in the
third line in &lt;name&gt;=&lt;value&gt; format, after other attribute specifications
(such as &#8220;meta&#8221; or &#8220;class&#8221;), and are separated by spaces.</p>
</div>
<div class="section" id="reuse-of-descriptors">
<span id="variable-descriptor-reuse"></span><h2>Reuse of descriptors<a class="headerlink" href="#reuse-of-descriptors" title="Permalink to this headline">¶</a></h2>
<p>There are situations when variable descriptors need to be
reused. Typically, the user loads some training examples, trains a
classifier, and then loads a separate test set. For the classifier to
recognize the variables in the second data set, the descriptors, not
just the names, need to be the same.</p>
<p>When constructing new descriptors for data read from a file or during
unpickling, Orange checks whether an appropriate descriptor (with the same
name and, in case of discrete variables, also values) already exists and
reuses it. When new descriptors are constructed by explicitly calling
the above constructors, this always creates new descriptors and thus
new variables, although a variable with the same name may already exist.</p>
<p>The search for an existing variable is based on four attributes: the
variable&#8217;s name, type, ordered values, and unordered values. As for the
latter two, the values can be explicitly ordered by the user, e.g. in
the second line of the tab-delimited file. For instance, sizes can be
ordered as small, medium, or big.</p>
<p>The search for existing variables can end with one of the following
statuses.</p>
<dl class="data">
<dt id="Orange.feature.Descriptor.MakeStatus.NotFound">
<tt class="descclassname">Descriptor.MakeStatus.</tt><tt class="descname">NotFound</tt><big>(</big><em>4</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.MakeStatus.NotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>The variable with that name and type does not exist.</p>
</dd></dl>

<dl class="data">
<dt id="Orange.feature.Descriptor.MakeStatus.Incompatible">
<tt class="descclassname">Descriptor.MakeStatus.</tt><tt class="descname">Incompatible</tt><big>(</big><em>3</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.MakeStatus.Incompatible" title="Permalink to this definition">¶</a></dt>
<dd><p>There are variables with matching name and type, but their values
are incompatible with the prescribed ordered values. For example,
if the existing variable already has values [&#8220;a&#8221;, &#8220;b&#8221;] and the new
one wants [&#8220;b&#8221;, &#8220;a&#8221;], the old variable cannot be reused. The
existing list can, however be appended with the new values, so
searching for [&#8220;a&#8221;, &#8220;b&#8221;, &#8220;c&#8221;] would succeed. Likewise a search for
[&#8220;a&#8221;] would be successful, since the extra existing value does not
matter. The formal rule is thus that the values are compatible iff
<tt class="docutils literal"><span class="pre">existing_values[:len(ordered_values)]</span> <span class="pre">==</span>
<span class="pre">ordered_values[:len(existing_values)]</span></tt>.</p>
</dd></dl>

<dl class="data">
<dt id="Orange.feature.Descriptor.MakeStatus.NoRecognizedValues">
<tt class="descclassname">Descriptor.MakeStatus.</tt><tt class="descname">NoRecognizedValues</tt><big>(</big><em>2</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.MakeStatus.NoRecognizedValues" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a matching variable, yet it has none of the values that
the new variable will have (this is obviously possible only if the
new variable has no prescribed ordered values). For instance, we
search for a variable &#8220;sex&#8221; with values &#8220;male&#8221; and &#8220;female&#8221;, while
there is a variable of the same name with values &#8220;M&#8221; and &#8220;F&#8221; (or,
well, &#8220;no&#8221; and &#8220;yes&#8221; :). Reuse of this variable is possible,
though this should probably be a new variable since it obviously
comes from a different data set. If we do decide to reuse the
variable, the old variable will get some unneeded new values and
the new one will inherit some from the old.</p>
</dd></dl>

<dl class="data">
<dt id="Orange.feature.Descriptor.MakeStatus.MissingValues">
<tt class="descclassname">Descriptor.MakeStatus.</tt><tt class="descname">MissingValues</tt><big>(</big><em>1</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.MakeStatus.MissingValues" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a matching variable with some of the values that the new
one requires, but some values are missing. This situation is
neither uncommon nor suspicious: in case of separate training and
testing data sets there may be values which occur in one set but
not in the other.</p>
</dd></dl>

<dl class="data">
<dt id="Orange.feature.Descriptor.MakeStatus.OK">
<tt class="descclassname">Descriptor.MakeStatus.</tt><tt class="descname">OK</tt><big>(</big><em>0</em><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Permalink to this definition">¶</a></dt>
<dd><p>There is a perfect match which contains all the prescribed values
in the correct order. The existing variable may have some extra
values, though.</p>
</dd></dl>

<p>Continuous variables can obviously have only two statuses,
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NotFound" title="Orange.feature.Descriptor.MakeStatus.NotFound"><tt class="xref py py-obj docutils literal"><span class="pre">NotFound</span></tt></a> or <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Orange.feature.Descriptor.MakeStatus.OK"><tt class="xref py py-obj docutils literal"><span class="pre">OK</span></tt></a>.</p>
<p>When loading the data using <a class="reference internal" href="Orange.data.table.html#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a>, Orange takes the
safest approach and, by default, reuses everything that is compatible
up to and including
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NoRecognizedValues" title="Orange.feature.Descriptor.MakeStatus.NoRecognizedValues"><tt class="xref py py-obj docutils literal"><span class="pre">NoRecognizedValues</span></tt></a>. Unintended reuse
would be obvious from the variable having too many values, which the
user can notice and fix. More on that in the page on
<a class="reference internal" href="Orange.data.formats.html"><em>Loading and saving data</em></a>.</p>
<p>There are two functions for reusing the variables instead of creating
new ones.</p>
<dl class="function">
<dt id="Orange.feature.Descriptor.make">
<tt class="descclassname">Descriptor.</tt><tt class="descname">make</tt><big>(</big><em>name</em>, <em>type</em>, <em>ordered_values</em>, <em>unordered_values</em><span class="optional">[</span>, <em>create_new_on</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.make" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return an existing variable or create a new one if none
of the existing variables matches the given name, type and values.</p>
<p>The optional <cite>create_new_on</cite> specifies the status at which a new
variable is created. The status must be at most
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.Incompatible" title="Orange.feature.Descriptor.MakeStatus.Incompatible"><tt class="xref py py-obj docutils literal"><span class="pre">Incompatible</span></tt></a> since incompatible (or
non-existing) variables cannot be reused. If it is set lower, for
instance to <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.MissingValues" title="Orange.feature.Descriptor.MakeStatus.MissingValues"><tt class="xref py py-obj docutils literal"><span class="pre">MissingValues</span></tt></a>, a new
variable is created even if there exists a variable which is only
missing the same values. If set to
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Orange.feature.Descriptor.MakeStatus.OK"><tt class="xref py py-obj docutils literal"><span class="pre">OK</span></tt></a>, the function always creates a
new variable.</p>
<p>The function returns a tuple containing a variable descriptor and
the status of the best matching variable. So, if <tt class="docutils literal"><span class="pre">create_new_on</span></tt>
is set to <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.MissingValues" title="Orange.feature.Descriptor.MakeStatus.MissingValues"><tt class="xref py py-obj docutils literal"><span class="pre">MissingValues</span></tt></a>, and there
exists a variable whose status is, say,
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NoRecognizedValues" title="Orange.feature.Descriptor.MakeStatus.NoRecognizedValues"><tt class="xref py py-obj docutils literal"><span class="pre">NoRecognizedValues</span></tt></a>, a variable would
be created, while the second element of the tuple would contain
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NoRecognizedValues" title="Orange.feature.Descriptor.MakeStatus.NoRecognizedValues"><tt class="xref py py-obj docutils literal"><span class="pre">NoRecognizedValues</span></tt></a>. If, on the other
hand, there exists a variable which is perfectly OK, its
descriptor is returned and the returned status is
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Orange.feature.Descriptor.MakeStatus.OK"><tt class="xref py py-obj docutils literal"><span class="pre">OK</span></tt></a>. The function returns no
indicator whether the returned variable is reused or not. This can
be, however, read from the status code: if it is smaller than the
specified <tt class="docutils literal"><span class="pre">create_new_on</span></tt>, the variable is reused, otherwise a
new descriptor has been constructed.</p>
<p>The exception to the rule is when <tt class="docutils literal"><span class="pre">create_new_on</span></tt> is OK. In this
case, the function does not search through the existing variables
and cannot know the status, so the returned status in this case is
always <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Orange.feature.Descriptor.MakeStatus.OK"><tt class="xref py py-obj docutils literal"><span class="pre">OK</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; Descriptor name</li>
<li><strong>type</strong> (<em>Type</em>) &#8211; Descriptor type</li>
<li><strong>ordered_values</strong> &#8211; a list of ordered values</li>
<li><strong>unordered_values</strong> &#8211; a list of values, for which the order does not
matter</li>
<li><strong>create_new_on</strong> &#8211; gives the condition for constructing a new variable instead
of using the new one</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return_type :</th><td class="field-body"><p class="first last">a tuple (<a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a>, int)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Orange.feature.Descriptor.retrieve">
<tt class="descclassname">Descriptor.</tt><tt class="descname">retrieve</tt><big>(</big><em>name</em>, <em>type</em>, <em>ordered_values</em>, <em>onordered_values</em><span class="optional">[</span>, <em>create_new_on</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.feature.Descriptor.retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return an existing variable, or <a class="reference external" href="http://docs.python.org/library/constants.html#None" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">None</span></tt></a> if no match is found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; variable name.</li>
<li><strong>type</strong> (<em>Type</em>) &#8211; variable type.</li>
<li><strong>ordered_values</strong> &#8211; a list of ordered values</li>
<li><strong>unordered_values</strong> &#8211; a list of values, for which the order does not
matter</li>
<li><strong>create_new_on</strong> &#8211; gives the condition for constructing a new variable instead
of using the new one</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return_type :</th><td class="field-body"><p class="first last"><a class="reference internal" href="#Orange.feature.Descriptor" title="Orange.feature.Descriptor"><tt class="xref py py-class docutils literal"><span class="pre">Descriptor</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The following examples give the shown results if
executed only once (in a Python session) and in this order.</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">make()</span></tt> can be used for the construction of new variables.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span>
<span class="go">NotFound &lt;a, b&gt;</span>
</pre></div>
</div>
<p>A new variable was created and the status is
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NotFound" title="Orange.feature.Descriptor.MakeStatus.NotFound"><tt class="xref py py-obj docutils literal"><span class="pre">NotFound</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span>
<span class="go">MissingValues True &lt;a, b, c&gt;</span>
</pre></div>
</div>
<p>The status is <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.MissingValues" title="Orange.feature.Descriptor.MakeStatus.MissingValues"><tt class="xref py py-obj docutils literal"><span class="pre">MissingValues</span></tt></a>, yet the
variable is reused (<tt class="docutils literal"><span class="pre">v2</span> <span class="pre">is</span> <span class="pre">v1</span></tt>). <tt class="docutils literal"><span class="pre">v1</span></tt> gets a new value, <tt class="docutils literal"><span class="pre">&quot;c&quot;</span></tt>,
which was given as an unordered value. It does not matter that the new
variable does not need the value <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v3</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v3</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span>
<span class="go">MissingValues True &lt;a, b, c, d&gt;</span>
</pre></div>
</div>
<p>This is like before, except that the new value, <tt class="docutils literal"><span class="pre">d</span></tt> is not among the
ordered values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v4</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v4</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v4</span><span class="o">.</span><span class="n">values</span>
<span class="go">Incompatible, False, &lt;b&gt;, &lt;a, b, c, d&gt;</span>
</pre></div>
</div>
<p>The new variable needs to have <tt class="docutils literal"><span class="pre">b</span></tt> as the first value, so it is
incompatible with the existing variables. The status is
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.Incompatible" title="Orange.feature.Descriptor.MakeStatus.Incompatible"><tt class="xref py py-obj docutils literal"><span class="pre">Incompatible</span></tt></a> and a new variable is
created; the two variables are not equal and have different lists of
values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v5</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v5</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v5</span><span class="o">.</span><span class="n">values</span>
<span class="go">OK True &lt;a, b, c, d&gt; &lt;a, b, c, d&gt;</span>
</pre></div>
</div>
<p>The new variable has values <tt class="docutils literal"><span class="pre">c</span></tt> and <tt class="docutils literal"><span class="pre">a</span></tt>, but the order is not
important, so the existing attribute is
<a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.OK" title="Orange.feature.Descriptor.MakeStatus.OK"><tt class="xref py py-obj docutils literal"><span class="pre">OK</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v6</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;e&quot;</span><span class="p">])</span> <span class="s">&quot;a&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v6</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v6</span><span class="o">.</span><span class="n">values</span>
<span class="go">NoRecognizedValues True &lt;a, b, c, d, e&gt; &lt;a, b, c, d, e&gt;</span>
</pre></div>
</div>
<p>The new variable has different values than the existing variable
(status is <a class="reference internal" href="#Orange.feature.Descriptor.MakeStatus.NoRecognizedValues" title="Orange.feature.Descriptor.MakeStatus.NoRecognizedValues"><tt class="xref py py-obj docutils literal"><span class="pre">NoRecognizedValues</span></tt></a>), but the
existing one is nonetheless reused. Note that we gave <tt class="docutils literal"><span class="pre">e</span></tt> in the
list of unordered values. If it was among the ordered, the reuse would
fail.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v7</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
<span class="go">        [&quot;f&quot;], Orange.feature.MakeStatus.NoRecognizedValues)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v7</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v7</span><span class="o">.</span><span class="n">values</span>
<span class="go">Incompatible False &lt;a, b, c, d, e&gt; &lt;f&gt;</span>
</pre></div>
</div>
<p>This is the same as before, except that we prohibited reuse when there
are no recognized values. Hence a new variable is created, though the
returned status is the same as before:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v8</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Descriptor</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Discrete</span><span class="p">,</span>
<span class="go">        [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;], None, Orange.feature.MakeStatus.OK)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">s</span><span class="p">,</span> <span class="n">v8</span> <span class="ow">is</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v8</span><span class="o">.</span><span class="n">values</span>
<span class="go">OK False &lt;a, b, c, d, e&gt; &lt;a, b, c, d, e&gt;</span>
</pre></div>
</div>
<p>Finally, this is a perfect match, but any reuse is prohibited, so a
new variable is created.</p>
</div>
<div class="section" id="variables-computed-from-other-variables">
<h2>Variables computed from other variables<a class="headerlink" href="#variables-computed-from-other-variables" title="Permalink to this headline">¶</a></h2>
<p>Values of variables are often computed from other variables, for
instance in. The mechanism described below usually functions behind
the scenes, so understanding it is required only for implementing
specific transformations.</p>
<p>Monk 1 is a well-known dataset with target concept <tt class="docutils literal"><span class="pre">y</span> <span class="pre">:=</span> <span class="pre">a==b</span> <span class="pre">or</span> <span class="pre">e==1</span></tt>.
It can help the learning algorithm if the four-valued attribute <tt class="docutils literal"><span class="pre">e</span></tt> is
replaced with a binary attribute having values <cite>&#8220;1&#8221;</cite> and <cite>&#8220;not 1&#8221;</cite>. The
new variable will be computed from the old one on the fly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="k">def</span> <span class="nf">checkE</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">return_what</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inst</span><span class="p">[</span><span class="s">&quot;e&quot;</span><span class="p">]</span><span class="o">==</span><span class="s">&quot;1&quot;</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">e2</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e2</span><span class="p">(</span><span class="s">&quot;not 1&quot;</span><span class="p">)</span> 

<span class="n">monks</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;monks-1&quot;</span><span class="p">)</span>
<span class="n">e2</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">Discrete</span><span class="p">(</span><span class="s">&quot;e2&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;not 1&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">])</span>    
<span class="n">e2</span><span class="o">.</span><span class="n">get_value_from</span> <span class="o">=</span> <span class="n">checkE</span> 
</pre></div>
</div>
<p>The new variable is named <tt class="docutils literal"><span class="pre">e2</span></tt>; we define it with a descriptor of
type <a class="reference internal" href="#Orange.feature.Discrete" title="Orange.feature.Discrete"><tt class="xref py py-obj docutils literal"><span class="pre">Discrete</span></tt></a>, with appropriate name and values <tt class="docutils literal"><span class="pre">&quot;not</span> <span class="pre">1&quot;</span></tt> and
<tt class="docutils literal"><span class="pre">1</span></tt> (we chose this order so that the <tt class="docutils literal"><span class="pre">not</span> <span class="pre">1</span></tt>&#8216;s index is <tt class="docutils literal"><span class="pre">0</span></tt>,
which can be, if needed, interpreted as <tt class="docutils literal"><span class="pre">False</span></tt>). Finally, we tell
e2 to use <tt class="docutils literal"><span class="pre">checkE</span></tt> to compute its value when needed, by assigning
<tt class="docutils literal"><span class="pre">checkE</span></tt> to <tt class="docutils literal"><span class="pre">e2.get_value_from</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">checkE</span></tt> is a function that is passed an instance and another
argument we do not care about here. If the instance&#8217;s <tt class="docutils literal"><span class="pre">e</span></tt> equals
<tt class="docutils literal"><span class="pre">1</span></tt>, the function returns value <tt class="docutils literal"><span class="pre">1</span></tt>, otherwise it returns <tt class="docutils literal"><span class="pre">not</span>
<span class="pre">1</span></tt>. Both are returned as values, not plain strings.</p>
<p>In most circumstances the value of <tt class="docutils literal"><span class="pre">e2</span></tt> can be computed on the fly -
we can pretend that the variable exists in the data, although it does
not (but can be computed from it). For instance, we can compute the
information gain of variable <tt class="docutils literal"><span class="pre">e2</span></tt> or its distribution without
actually constructing data containing the new variable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">Orange</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">scoring</span><span class="o">.</span><span class="n">InfoGain</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">monks</span><span class="p">)</span>

<span class="n">dist</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">distribution</span><span class="o">.</span><span class="n">Distribution</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">monks</span><span class="p">)</span>
<span class="k">print</span> <span class="n">dist</span> 
</pre></div>
</div>
<p>There are methods which cannot compute values on the fly because it
would be too complex or time consuming. In such cases, the data need
to be converted to a new <a class="reference internal" href="Orange.data.table.html#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Table</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">new_domain</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Domain</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">],</span> <span class="n">e2</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">class_var</span><span class="p">])</span>
<span class="n">new_data</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">new_domain</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Automatic computation is useful when the data is split into training
and testing examples. Training instances can be modified by adding,
removing and transforming variables (in a typical setup, continuous
variables are discretized prior to learning, therefore the original
variables are replaced by new ones). Test instances, on the other
hand, are left as they are. When they are classified, the classifier
automatically converts the testing instances into the new domain,
which includes recomputation of transformed variables.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Split the data into training and testing set</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">SubsetIndices2</span><span class="p">(</span><span class="n">monks</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">train_data</span> <span class="o">=</span> <span class="n">monks</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">monks</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Convert the training set to a new domain</span>
<span class="n">new_domain</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Domain</span><span class="p">([</span><span class="n">monks</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">],</span> <span class="n">monks</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">],</span> <span class="n">e2</span><span class="p">,</span> <span class="n">monks</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">class_var</span><span class="p">])</span>
<span class="n">new_train</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">new_domain</span><span class="p">,</span> <span class="n">train_data</span><span class="p">)</span>

<span class="c"># Construct a tree and classify unmodified instances</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">new_train</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">test_data</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">ex</span><span class="o">.</span><span class="n">getclass</span><span class="p">(),</span> <span class="n">tree</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>



          </div>
        </div>
      </div> 
      <div class="clearer"></div>
    </div>  
	
    <div class="footer">
    </div>
	            </div>
        </div>
        <div class="border1"></div>
        <div class="border2"></div>
    </div>
</div>

  </body>
</html>