
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classification trees (tree) &mdash; Orange Documentation v2.7.8</title>
    
    <link rel="stylesheet" href="../../_static/orange.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.7.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Orange Documentation v2.7.8" href="../../index.html" />
    <script type="text/javascript" src="../../_static/copybutton.js"></script>

  </head>
  <body>
	<div id="container">
    <div class="border1"></div>
    <div class="border2"></div>
    <div class="borderv">
        <div id="header">
			<div id="orangeimg"><h1><a href="http://orange.biolab.si"><img src="../../_static/orange-logo-w.png" alt="Orange" /></a></h1></div>

            <div id="cse-search-box" style="height: 22px;"></div>
            <div id="underimg"></div>
        </div>
    </div>
    <div class="border2"></div>
    <div class="border1"></div>

    <div id="main">
        <div class="border1"></div>
        <div class="border2"></div>
        <div class="borderv">
            <div id="maininner">
            <p style="font-size: 32px;">
                This is documentation for Orange 2.7. For the latest documentation, 
                <a href="http://orange.biolab.si/docs">
                see Orange 3</a>.
            </p>
 

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
    <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
           <p><a class="uplink" href="../../index.html">Orange Documentation v2.7.8</a></p>
           <ul>
<li><a class="reference internal" href="#">Classification trees (<tt class="docutils literal"><span class="pre">tree</span></tt>)</a><ul>
<li><a class="reference internal" href="#component-based-tree-inducer">Component-based Tree Inducer</a><ul>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#tree-structure">Tree Structure</a></li>
<li><a class="reference internal" href="#setting-learning-parameters">Setting learning parameters</a></li>
<li><a class="reference internal" href="#redefining-tree-induction-components">Redefining tree induction components</a></li>
</ul>
</li>
<li><a class="reference internal" href="#learner-and-classifier-components">Learner and Classifier Components</a><ul>
<li><a class="reference internal" href="#split-constructors">Split constructors</a></li>
<li><a class="reference internal" href="#stopcriteria-and-stopcriteria-common">StopCriteria and StopCriteria_common</a></li>
<li><a class="reference internal" href="#splitters">Splitters</a></li>
<li><a class="reference internal" href="#descenders">Descenders</a></li>
<li><a class="reference internal" href="#pruning">Pruning</a></li>
<li><a class="reference internal" href="#printing-the-tree">Printing the tree</a><ul>
<li><a class="reference internal" href="#format-string">Format string</a></li>
<li><a class="reference internal" href="#defining-custom-printouts">Defining custom printouts</a></li>
<li><a class="reference internal" href="#plotting-with-dot">Plotting with Dot</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#c4-5-tree-inducer">C4.5 Tree Inducer</a><ul>
<li><a class="reference internal" href="#building-the-c4-5-plug-in">Building the C4.5 plug-in</a></li>
<li><a class="reference internal" href="#id1">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simple-tree-inducer">Simple Tree Inducer</a><ul>
<li><a class="reference internal" href="#id2">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
    
  <span class="target" id="index-0"></span><div class="section" id="classification-trees-tree">
<span id="index-1"></span><h1>Classification trees (<tt class="docutils literal"><span class="pre">tree</span></tt>)<a class="headerlink" href="#classification-trees-tree" title="Permalink to this headline">¶</a></h1>
<p>Orange includes multiple implementations of classification tree learners:
a very flexible <a class="reference internal" href="#Orange.classification.tree.TreeLearner" title="Orange.classification.tree.TreeLearner"><tt class="xref py py-class docutils literal"><span class="pre">TreeLearner</span></tt></a>, a fast <a class="reference internal" href="#Orange.classification.tree.SimpleTreeLearner" title="Orange.classification.tree.SimpleTreeLearner"><tt class="xref py py-class docutils literal"><span class="pre">SimpleTreeLearner</span></tt></a>,
and a <a class="reference internal" href="#Orange.classification.tree.C45Learner" title="Orange.classification.tree.C45Learner"><tt class="xref py py-class docutils literal"><span class="pre">C45Learner</span></tt></a>, which uses the C4.5 tree induction
algorithm.</p>
<p>The following code builds a <a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">TreeClassifier</span></tt></a> on the Iris data set
(with the depth limited to three levels):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;iris&quot;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">iris</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Decision_tree_learning">Decision tree learning</a> on Wikipedia
for introduction to classification trees.</p>
<div class="section" id="component-based-tree-inducer">
<h2>Component-based Tree Inducer<a class="headerlink" href="#component-based-tree-inducer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Orange.classification.tree.TreeLearner">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">TreeLearner</tt><big>(</big><em>**kw</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeLearner" title="Permalink to this definition">¶</a></dt>
<dd><p>A classification or regression tree learner. If a set of instances
is given on initialization, a <a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-class docutils literal"><span class="pre">TreeClassifier</span></tt></a> is built and
returned instead.</p>
<p>The learning algorithm has a large number of parameters. The class
provides reasonable defaults; they can be modified either as attributes
or as arguments given to the constructor.</p>
<p>The algorithm is very flexible, yet slower than the other two
implementations that are more suitable for large scale
experiments.</p>
<p><strong>The tree induction process</strong></p>
<ol class="arabic simple">
<li>The learning instances are copied, unless
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.store_instances" title="Orange.classification.tree.TreeLearner.store_instances"><tt class="xref py py-obj docutils literal"><span class="pre">store_instances</span></tt></a> is <cite>False</cite> and the instance
already are stored in a <a class="reference internal" href="Orange.data.table.html#Orange.data.Table" title="Orange.data.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a>.</li>
<li>Apriori class probabilities are computed. A list of
candidate features for the split is compiled; in the beginning,
all features are candidates.</li>
<li>The recursive part. The contingency matrix is computed by
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.contingency_computer" title="Orange.classification.tree.TreeLearner.contingency_computer"><tt class="xref py py-obj docutils literal"><span class="pre">contingency_computer</span></tt></a>. Contingencies are used by <a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a>,
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.stop" title="Orange.classification.tree.TreeLearner.stop"><tt class="xref py py-obj docutils literal"><span class="pre">stop</span></tt></a> and <a class="reference internal" href="#Orange.classification.tree.TreeLearner.splitter" title="Orange.classification.tree.TreeLearner.splitter"><tt class="xref py py-obj docutils literal"><span class="pre">splitter</span></tt></a>.</li>
<li>If the induction should <a class="reference internal" href="#Orange.classification.tree.TreeLearner.stop" title="Orange.classification.tree.TreeLearner.stop"><tt class="xref py py-obj docutils literal"><span class="pre">stop</span></tt></a>, a <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a>
is built by calling <a class="reference internal" href="#Orange.classification.tree.TreeLearner.node_learner" title="Orange.classification.tree.TreeLearner.node_learner"><tt class="xref py py-obj docutils literal"><span class="pre">node_learner</span></tt></a> with the given instances,
weight ID and the contingency matrix. As the learner uses
contingencies whenever possible, the <a class="reference internal" href="#Orange.classification.tree.TreeLearner.contingency_computer" title="Orange.classification.tree.TreeLearner.contingency_computer"><tt class="xref py py-obj docutils literal"><span class="pre">contingency_computer</span></tt></a>
will affect the <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a>. The node is returned.</li>
<li>If the induction continues, a <a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a> is called.
If <a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a> fails to return a branch selector, induction stops 
and the <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> is returned.</li>
<li>The feature spent (if any) is removed from the candidate list.</li>
<li>Instances are divided into child nodes with <a class="reference internal" href="#Orange.classification.tree.TreeLearner.splitter" title="Orange.classification.tree.TreeLearner.splitter"><tt class="xref py py-obj docutils literal"><span class="pre">splitter</span></tt></a>.
The process recursively continues with step 3 for
each of the non-empty subsets. If the splitter returned weights,
they are used for each branch.</li>
</ol>
<p><strong>Attributes</strong></p>
<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.node_learner">
<tt class="descname">node_learner</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.node_learner" title="Permalink to this definition">¶</a></dt>
<dd><p>Induces a classifier from instances in a node. It is used both
for internal nodes and leaves. The default is
<a class="reference internal" href="Orange.classification.majority.html#Orange.classification.majority.MajorityLearner" title="Orange.classification.majority.MajorityLearner"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.classification.majority.MajorityLearner</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.descender">
<tt class="descname">descender</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.descender" title="Permalink to this definition">¶</a></dt>
<dd><p>The descender that the induced <a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">TreeClassifier</span></tt></a> will
use. The default is <a class="reference internal" href="#Orange.classification.tree.Descender_UnknownMergeAsSelector" title="Orange.classification.tree.Descender_UnknownMergeAsSelector"><tt class="xref py py-obj docutils literal"><span class="pre">Descender_UnknownMergeAsSelector</span></tt></a>.
It votes with the <tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt>&#8216;s distribution for
vote weights.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.contingency_computer">
<tt class="descname">contingency_computer</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.contingency_computer" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the computation of contingency matrices (used by
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a>, <a class="reference internal" href="#Orange.classification.tree.TreeLearner.stop" title="Orange.classification.tree.TreeLearner.stop"><tt class="xref py py-obj docutils literal"><span class="pre">stop</span></tt></a>, <a class="reference internal" href="#Orange.classification.tree.TreeLearner.splitter" title="Orange.classification.tree.TreeLearner.splitter"><tt class="xref py py-obj docutils literal"><span class="pre">splitter</span></tt></a>). It can be used,
for example, to change the treatment of unknown values. By
default ordinary contingency matrices are computed.</p>
</dd></dl>

<p><strong>Split construction</strong></p>
<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.split">
<tt class="descname">split</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.split" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a> or a function with the same signature as
<a class="reference internal" href="#Orange.classification.tree.SplitConstructor.__call__" title="Orange.classification.tree.SplitConstructor.__call__"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor.__call__</span></tt></a>. It is useful for prototyping
new tree induction algorithms. If <a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a> is defined, other 
arguments that affect split construction are ignored. These include
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.binarization" title="Orange.classification.tree.TreeLearner.binarization"><tt class="xref py py-obj docutils literal"><span class="pre">binarization</span></tt></a>, <a class="reference internal" href="#Orange.classification.tree.TreeLearner.measure" title="Orange.classification.tree.TreeLearner.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a>, <a class="reference internal" href="#Orange.classification.tree.TreeLearner.worst_acceptable" title="Orange.classification.tree.TreeLearner.worst_acceptable"><tt class="xref py py-obj docutils literal"><span class="pre">worst_acceptable</span></tt></a> and
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.min_subset" title="Orange.classification.tree.TreeLearner.min_subset"><tt class="xref py py-obj docutils literal"><span class="pre">min_subset</span></tt></a>. Default: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Combined" title="Orange.classification.tree.SplitConstructor_Combined"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Combined</span></tt></a>
with separate constructors for discrete and continuous
features. Discrete features are used as they are, while
continuous are binarized. Features are scored with gain ratio.
At least two instances in a leaf are required for
discrete and five for continuous features.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.binarization">
<tt class="descname">binarization</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.binarization" title="Permalink to this definition">¶</a></dt>
<dd><p>If 1, <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_ExhaustiveBinary" title="Orange.classification.tree.SplitConstructor_ExhaustiveBinary"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_ExhaustiveBinary</span></tt></a> is used.
If 2, use <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_OneAgainstOthers" title="Orange.classification.tree.SplitConstructor_OneAgainstOthers"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_OneAgainstOthers</span></tt></a>. If
0, do not use binarization (use <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Feature" title="Orange.classification.tree.SplitConstructor_Feature"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Feature</span></tt></a>).
Default: 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.measure">
<tt class="descname">measure</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>A score to evaluate features for splitting instances in a
node.  A subclass of <a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Score" title="Orange.feature.scoring.Score"><tt class="xref py py-class docutils literal"><span class="pre">Orange.feature.scoring.Score</span></tt></a>
(perhaps <a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.InfoGain" title="Orange.feature.scoring.InfoGain"><tt class="xref py py-class docutils literal"><span class="pre">InfoGain</span></tt></a>,
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.GainRatio" title="Orange.feature.scoring.GainRatio"><tt class="xref py py-class docutils literal"><span class="pre">GainRatio</span></tt></a>,
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Gini" title="Orange.feature.scoring.Gini"><tt class="xref py py-class docutils literal"><span class="pre">Gini</span></tt></a>,
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Relief" title="Orange.feature.scoring.Relief"><tt class="xref py py-class docutils literal"><span class="pre">Relief</span></tt></a>, or
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.MSE" title="Orange.feature.scoring.MSE"><tt class="xref py py-class docutils literal"><span class="pre">MSE</span></tt></a>). Default:
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.GainRatio" title="Orange.feature.scoring.GainRatio"><tt class="xref py py-class docutils literal"><span class="pre">Orange.feature.scoring.GainRatio</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">relief_m, relief_k</tt></dt>
<dd><p>Set <cite>m</cite> and <cite>k</cite> for <a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Relief" title="Orange.feature.scoring.Relief"><tt class="xref py py-class docutils literal"><span class="pre">Relief</span></tt></a>,
if chosen.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.splitter">
<tt class="descname">splitter</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.splitter" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a> or a function with the same
signature as <a class="reference internal" href="#Orange.classification.tree.Splitter.__call__" title="Orange.classification.tree.Splitter.__call__"><tt class="xref py py-obj docutils literal"><span class="pre">Splitter.__call__</span></tt></a>. The default is
<a class="reference internal" href="#Orange.classification.tree.Splitter_UnknownsAsSelector" title="Orange.classification.tree.Splitter_UnknownsAsSelector"><tt class="xref py py-class docutils literal"><span class="pre">Splitter_UnknownsAsSelector</span></tt></a> that splits the
learning instances according to distributions given by the
selector.</p>
</dd></dl>

<p><strong>Pruning</strong></p>
<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.worst_acceptable">
<tt class="descname">worst_acceptable</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.worst_acceptable" title="Permalink to this definition">¶</a></dt>
<dd><p>The lowest required feature score. If the score of the best
feature is below this margin, the tree is not grown further
(default: 0).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.min_subset">
<tt class="descname">min_subset</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.min_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>The lowest required number of instances in non-null leaves (default: 0).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.min_instances">
<tt class="descname">min_instances</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.min_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Data subsets with less than <a class="reference internal" href="#Orange.classification.tree.TreeLearner.min_instances" title="Orange.classification.tree.TreeLearner.min_instances"><tt class="xref py py-obj docutils literal"><span class="pre">min_instances</span></tt></a>
instances are not split any further. Therefore, all leaves in the tree
will contain at least that many instances (default: 0).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.max_depth">
<tt class="descname">max_depth</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.max_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximal tree depth. If 0, only root is generated. 
The default is 100.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.max_majority">
<tt class="descname">max_majority</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.max_majority" title="Permalink to this definition">¶</a></dt>
<dd><p>Induction stops when the proportion of majority class in the
node exceeds the value set by this parameter (default: 1.0).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.stop">
<tt class="descname">stop</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.stop" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Orange.classification.tree.StopCriteria" title="Orange.classification.tree.StopCriteria"><tt class="xref py py-class docutils literal"><span class="pre">StopCriteria</span></tt></a> or a function with the same signature as
<a class="reference internal" href="#Orange.classification.tree.StopCriteria.__call__" title="Orange.classification.tree.StopCriteria.__call__"><tt class="xref py py-obj docutils literal"><span class="pre">StopCriteria.__call__</span></tt></a>. Useful for prototyping new tree
induction algorithms.  When used, parameters  <a class="reference internal" href="#Orange.classification.tree.TreeLearner.max_majority" title="Orange.classification.tree.TreeLearner.max_majority"><tt class="xref py py-obj docutils literal"><span class="pre">max_majority</span></tt></a>
and <a class="reference internal" href="#Orange.classification.tree.TreeLearner.min_instances" title="Orange.classification.tree.TreeLearner.min_instances"><tt class="xref py py-obj docutils literal"><span class="pre">min_instances</span></tt></a> will not be  considered.  The default
stopping criterion stops induction when all instances in a node
belong to the same class.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.m_pruning">
<tt class="descname">m_pruning</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.m_pruning" title="Permalink to this definition">¶</a></dt>
<dd><p>If non-zero, invokes an error-based bottom-up post-pruning,
where m-estimate is used to estimate class probabilities 
(default: 0).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.same_majority_pruning">
<tt class="descname">same_majority_pruning</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.same_majority_pruning" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, invokes a bottom-up post-pruning by removing the
subtrees of which all leaves classify to the same class
(default: False).</p>
</dd></dl>

<p><strong>Record keeping</strong></p>
<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.store_distributions">
<tt class="descname">store_distributions</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.store_distributions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.store_contingencies">
<tt class="descname">store_contingencies</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.store_contingencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.store_instances">
<tt class="descname">store_instances</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.store_instances" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeLearner.store_node_classifier">
<tt class="descname">store_node_classifier</tt><a class="headerlink" href="#Orange.classification.tree.TreeLearner.store_node_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether to store class distributions,
contingencies and instances in <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a>, and whether the
<a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">Node.node_classifier</span></tt></a> should be build for internal nodes
also (it is needed by the <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a> or for post-pruning).
Not storing distributions but storing contingencies does not
save any memory, since distributions actually points to the
same distribution that is stored in <tt class="xref py py-obj docutils literal"><span class="pre">contingency.classes</span></tt>.
By default everything except <a class="reference internal" href="#Orange.classification.tree.TreeLearner.store_instances" title="Orange.classification.tree.TreeLearner.store_instances"><tt class="xref py py-obj docutils literal"><span class="pre">store_instances</span></tt></a> is enabled.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeLearner.__call__">
<tt class="descname">__call__</tt><big>(</big><em>instances</em>, <em>weight=0</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeLearner.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a classifier from the given instances.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeLearner.instance">
<tt class="descname">instance</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeLearner.instance" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED. Return a base learner - an object 
of <tt class="xref py py-class docutils literal"><span class="pre">_TreeLearner</span></tt>. 
This method is left for backwards compatibility.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.TreeClassifier">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">TreeClassifier</tt><big>(</big><em>base_classifier=None</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies instances according to the tree stored in <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.tree" title="Orange.classification.tree.TreeClassifier.tree"><tt class="xref py py-obj docutils literal"><span class="pre">tree</span></tt></a>.</p>
<p><strong>The classification process</strong></p>
<p><a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">TreeClassifier</span></tt></a> uses the <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.descender" title="Orange.classification.tree.TreeClassifier.descender"><tt class="xref py py-obj docutils literal"><span class="pre">descender</span></tt></a> to descend the
instance from the root. If the <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.descender" title="Orange.classification.tree.TreeClassifier.descender"><tt class="xref py py-obj docutils literal"><span class="pre">descender</span></tt></a> returns only a
<a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> and no distribution, the descend should stop as the node
was unambiguously selected. The node&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a>
decides the class.</p>
<p>If the descender returns a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> and a distribution, as it
happens, for example, if the instance&#8217;s value for the <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a>&#8216;s
feature is unknown, the same process repeats for all subtrees and
their predictions are combined.</p>
<p><strong>Attributes</strong></p>
<dl class="attribute">
<dt id="Orange.classification.tree.TreeClassifier.tree">
<tt class="descname">tree</tt><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>The root of the tree, as a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-class docutils literal"><span class="pre">Node</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.TreeClassifier.descender">
<tt class="descname">descender</tt><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.descender" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a> used to descend an instance from the root as
deeply as possible according to the instance&#8217;s feature values.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeClassifier.__call__">
<tt class="descname">__call__</tt><big>(</big><em>instance</em>, <em>result_type=0</em>, <em>*args</em>, <em>**kwdargs</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify a new instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>instance</strong> (<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Instance</span></tt></a>) &#8211; instance to be classified.</li>
<li><strong>result_type</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetValue</span></tt> or               <tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetProbabilities</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetBoth</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a>, 
<tt class="xref py py-class docutils literal"><span class="pre">Orange.statistics.Distribution</span></tt> or a tuple with both</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeClassifier.count_leaves">
<tt class="descname">count_leaves</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.count_leaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of leaves.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeClassifier.count_nodes">
<tt class="descname">count_nodes</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.count_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeClassifier.dot">
<tt class="descname">dot</tt><big>(</big><em>file_name</em>, <em>leaf_str=</em>, <em>node_str=</em>, <em>leaf_shape=plaintext</em>, <em>node_shape=plaintext</em>, <em>user_formats=</em><span class="optional">[</span><span class="optional">]</span>, <em>min_instances=0</em>, <em>max_depth=10000000000</em>, <em>simple_first=True</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the tree to a file in a format used by <a class="reference external" href="http://www.research.att.com/sw/tools/graphviz">GraphViz</a>.  Uses the
same parameters as <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.to_string" title="Orange.classification.tree.TreeClassifier.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a> plus two which define the shape
of internal nodes and leaves of the tree:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>leaf_shape</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Shape of the outline around leaves of the tree. 
If &#8220;plaintext&#8221;, no outline is used (default: &#8220;plaintext&#8221;).</li>
<li><strong>node_shape</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Shape of the outline around internal nodes 
of the tree. If &#8220;plaintext&#8221;, no outline is used (default: &#8220;plaintext&#8221;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Check <a class="reference external" href="http://www.graphviz.org/doc/info/shapes.html">Polygon-based Nodes</a> 
for various outlines supported by GraphViz.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.TreeClassifier.to_string">
<tt class="descname">to_string</tt><big>(</big><em>leaf_str=</em>, <em>node_str=</em>, <em>user_formats=</em><span class="optional">[</span><span class="optional">]</span>, <em>min_instances=0</em>, <em>max_depth=10000000000</em>, <em>simple_first=True</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.TreeClassifier.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of a tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>leaf_str</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; The format string for the tree leaves. If 
left empty, <tt class="docutils literal"><span class="pre">&quot;%V</span> <span class="pre">(%^.2m%)&quot;</span></tt> will be used for classification trees
and <tt class="docutils literal"><span class="pre">&quot;%V&quot;</span></tt> for regression trees.</li>
<li><strong>node_str</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; The format string for the internal nodes.
If left empty (as it is by default), no data is printed out for
internal nodes. If set to <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>, the same string is
used as for leaves.</li>
<li><strong>max_depth</strong> (<em>integer</em>) &#8211; If set, it limits the depth to which the tree is
printed out.</li>
<li><strong>min_instances</strong> (<em>integer</em>) &#8211; If set, the subtrees with less than the given 
number of examples are not printed.</li>
<li><strong>simple_first</strong> (<em>boolean</em>) &#8211; If True (default), the branches with a single 
node are printed before the branches with larger subtrees. 
If False, the branches are printed in order of
appearance.</li>
<li><strong>user_formats</strong> &#8211; A list of regular expressions and callback 
function through which the user can print out other specific 
information in the nodes.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Node">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Node</tt><a class="headerlink" href="#Orange.classification.tree.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Classification trees are a hierarchy of <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> classes.</p>
<p>Node stores the instances belonging to the node, a branch selector,
a list of branches (if the node is not a leaf) with their descriptions
and strengths, and a classifier.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.Node.distribution">
<tt class="descname">distribution</tt><a class="headerlink" href="#Orange.classification.tree.Node.distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A distribution of learning instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.Node.contingency">
<tt class="descname">contingency</tt><a class="headerlink" href="#Orange.classification.tree.Node.contingency" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete contingency matrices for the learning instances.</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">instances, weightID</tt></dt>
<dd><p>Learning instances and the ID of weight meta attribute. The root
of the tree actually stores all instances, while other nodes
store only reference to instances in the root node.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.Node.node_classifier">
<tt class="descname">node_classifier</tt><a class="headerlink" href="#Orange.classification.tree.Node.node_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>A classifier for instances coming to the node. If the node is a
leaf, it chooses the class (or class distribution) of an instance.</p>
</dd></dl>

<p>Internal nodes have additional attributes. The lists <a class="reference internal" href="#Orange.classification.tree.Node.branches" title="Orange.classification.tree.Node.branches"><tt class="xref py py-obj docutils literal"><span class="pre">branches</span></tt></a>,
<a class="reference internal" href="#Orange.classification.tree.Node.branch_descriptions" title="Orange.classification.tree.Node.branch_descriptions"><tt class="xref py py-obj docutils literal"><span class="pre">branch_descriptions</span></tt></a> and <a class="reference internal" href="#Orange.classification.tree.Node.branch_sizes" title="Orange.classification.tree.Node.branch_sizes"><tt class="xref py py-obj docutils literal"><span class="pre">branch_sizes</span></tt></a> are of the
same length.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.Node.branches">
<tt class="descname">branches</tt><a class="headerlink" href="#Orange.classification.tree.Node.branches" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of subtrees. Each element is a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> or None.
If None, the node is empty.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.Node.branch_descriptions">
<tt class="descname">branch_descriptions</tt><a class="headerlink" href="#Orange.classification.tree.Node.branch_descriptions" title="Permalink to this definition">¶</a></dt>
<dd><p>A list with strings describing branches. They are constructed
by <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a>. A string can contain anything,
for example &#8216;red&#8217; or &#8216;&gt;12.3&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.Node.branch_sizes">
<tt class="descname">branch_sizes</tt><a class="headerlink" href="#Orange.classification.tree.Node.branch_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>A (weighted) number of training instances for
each branch. It can be used, for instance, for modeling
probabilities when classifying instances with unknown values.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.Node.branch_selector">
<tt class="descname">branch_selector</tt><a class="headerlink" href="#Orange.classification.tree.Node.branch_selector" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="Orange.classification.html#Orange.classification.Classifier" title="Orange.classification.Classifier"><tt class="xref py py-obj docutils literal"><span class="pre">Classifier</span></tt></a> that returns a branch
for each instance (as
<a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.data.Value</span></tt></a> in <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">len(branches)-1]</span></tt>).  When an
instance cannot be classified unambiguously, the selector can
return a discrete distribution, which proposes how to divide
the instance between the branches. Whether the proposition will
be used depends upon the <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-obj docutils literal"><span class="pre">Splitter</span></tt></a> (for learning)
or <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a> (for classification).</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.Node.tree_size">
<tt class="descname">tree_size</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.classification.tree.Node.tree_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the subtrees (including the node,
excluding null-nodes).</p>
</dd></dl>

</dd></dl>

<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tree-structure">
<h4>Tree Structure<a class="headerlink" href="#tree-structure" title="Permalink to this headline">¶</a></h4>
<p>This example works with the lenses data set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">Orange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lenses</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;lenses&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree_classifier</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">lenses</span><span class="p">)</span>
</pre></div>
</div>
<p>The following function counts the number of nodes in a tree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">tree_size</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="mi">0</span>
<span class="gp">... </span>   <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">branch_selector</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
<span class="gp">... </span>           <span class="n">size</span> <span class="o">+=</span> <span class="n">tree_size</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">size</span>
</pre></div>
</div>
<p>If node is None, the function above return 0. Otherwise, the size is 1
(this node) plus the sizes of all subtrees. The algorithm need to check
if a node is internal (it has a <a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a>), as leaves
don&#8217;t have the <a class="reference internal" href="#Orange.classification.tree.Node.branches" title="Orange.classification.tree.Node.branches"><tt class="xref py py-obj docutils literal"><span class="pre">branches</span></tt></a> attribute.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tree_size</span><span class="p">(</span><span class="n">tree_classifier</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
<p>Note that a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> already has a built-in method
<a class="reference internal" href="#Orange.classification.tree.Node.tree_size" title="Orange.classification.tree.Node.tree_size"><tt class="xref py py-func docutils literal"><span class="pre">tree_size()</span></tt></a>.</p>
<p>Trees can be printed with a simple recursive function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_tree0</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&quot; &quot;</span><span class="o">*</span><span class="n">level</span> <span class="o">+</span> <span class="s">&quot;&lt;null node&gt;&quot;</span>
<span class="gp">... </span>        <span class="k">return</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">branch_selector</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">node_desc</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">branch_selector</span><span class="o">.</span><span class="n">class_var</span><span class="o">.</span><span class="n">name</span>
<span class="gp">... </span>        <span class="n">node_cont</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">distribution</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">n&quot;</span> <span class="o">+</span> <span class="s">&quot;   &quot;</span><span class="o">*</span><span class="n">level</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node_desc</span><span class="p">,</span> <span class="n">node_cont</span><span class="p">),</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branches</span><span class="p">)):</span>
<span class="gp">... </span>            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">n&quot;</span> <span class="o">+</span> <span class="s">&quot;   &quot;</span><span class="o">*</span><span class="n">level</span> <span class="o">+</span> <span class="s">&quot;: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">branch_descriptions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
<span class="gp">... </span>            <span class="n">print_tree0</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">node_cont</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">distribution</span>
<span class="gp">... </span>        <span class="n">major_class</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node_classifier</span><span class="o">.</span><span class="n">default_value</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&quot;--&gt; </span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">) &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">major_class</span><span class="p">,</span> <span class="n">node_cont</span><span class="p">),</span>
</pre></div>
</div>
<p>The crux of the example is not in the formatting (\n&#8217;s etc.);
what matters is everything but the print statements. The code
separately handles three node types:</p>
<ul class="simple">
<li>For null nodes (a node to which no learning instances were classified),
it just prints &#8220;&lt;null node&gt;&#8221;.</li>
<li>For internal nodes, it prints a node description:
the feature&#8217;s name and distribution of classes. <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a>&#8216;s
branch description is an <a class="reference internal" href="Orange.classification.html#Orange.classification.Classifier" title="Orange.classification.Classifier"><tt class="xref py py-obj docutils literal"><span class="pre">Classifier</span></tt></a>,
and its <tt class="docutils literal"><span class="pre">class_var</span></tt> is the feature whose name is printed.  Class
distributions are printed as well (they are assumed to be stored).
The <tt class="xref py py-obj docutils literal"><span class="pre">print_tree0</span></tt> with a level increased by 1 to increase the
indent is recursively called for each branch.</li>
<li>If the node is a leaf, it prints the distribution of learning instances
in the node and the class to which the instances in the node would
be classified. We assume that the <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a> is a
<tt class="xref py py-obj docutils literal"><span class="pre">DefaultClassifier</span></tt>. A better print function should be aware of
possible alternatives.</li>
</ul>
<p>The wrapper function that accepts either a
<a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">TreeClassifier</span></tt></a> or a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> can be written as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeClassifier</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">print_tree0</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">print_tree0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="s">&quot;invalid parameter&quot;</span>
</pre></div>
</div>
<p>It&#8217;s straightforward: if <tt class="docutils literal"><span class="pre">x</span></tt> is a
<a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">TreeClassifier</span></tt></a>, it prints <tt class="docutils literal"><span class="pre">x.tree</span></tt>; if it&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> it
print <tt class="docutils literal"><span class="pre">x</span></tt>. If it&#8217;s of some other type,
an exception is raised. The output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">print_tree</span><span class="p">(</span><span class="n">tree_classifier</span><span class="p">)</span>

<span class="go">tear_rate (&lt;15.000, 4.000, 5.000&gt;)</span>
<span class="go">: normal</span>
<span class="go">   astigmatic (&lt;3.000, 4.000, 5.000&gt;)</span>
<span class="go">   : no</span>
<span class="go">      age (&lt;1.000, 0.000, 5.000&gt;)</span>
<span class="go">      : pre-presbyopic --&gt; soft (&lt;0.000, 0.000, 2.000&gt;)</span>
<span class="go">      : presbyopic</span>
<span class="go">         prescription (&lt;1.000, 0.000, 1.000&gt;)</span>
<span class="go">         : hypermetrope --&gt; soft (&lt;0.000, 0.000, 1.000&gt;)</span>
<span class="go">         : myope --&gt; none (&lt;1.000, 0.000, 0.000&gt;)</span>
<span class="go">      : young --&gt; soft (&lt;0.000, 0.000, 2.000&gt;)</span>
<span class="go">   : yes</span>
<span class="go">      prescription (&lt;2.000, 4.000, 0.000&gt;)</span>
<span class="go">      : hypermetrope</span>
<span class="go">         age (&lt;2.000, 1.000, 0.000&gt;)</span>
<span class="go">         : pre-presbyopic --&gt; none (&lt;1.000, 0.000, 0.000&gt;)</span>
<span class="go">         : presbyopic --&gt; none (&lt;1.000, 0.000, 0.000&gt;)</span>
<span class="go">         : young --&gt; hard (&lt;0.000, 1.000, 0.000&gt;)</span>
<span class="go">      : myope --&gt; hard (&lt;0.000, 3.000, 0.000&gt;)</span>
<span class="go">: reduced --&gt; none (&lt;12.000, 0.000, 0.000&gt;)</span>
</pre></div>
</div>
<p>The tree structure examples conclude with a simple pruning function,
written entirely in Python and unrelated to any <a class="reference internal" href="#Orange.classification.tree.Pruner" title="Orange.classification.tree.Pruner"><tt class="xref py py-class docutils literal"><span class="pre">Pruner</span></tt></a>. It limits
the tree depth (the number of internal nodes on any path down the tree).
For example, to get a two-level tree, call cut_tree(root, 2). The function
is recursive, with the second argument (level) decreasing at each call;
when zero, the current node will be made a leaf:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cut_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">branch_selector</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">level</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">cut_tree</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">node</span><span class="o">.</span><span class="n">branch_selector</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">... </span>            <span class="n">node</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">... </span>            <span class="n">node</span><span class="o">.</span><span class="n">branch_descriptions</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>The function acts only when <tt class="xref py py-obj docutils literal"><span class="pre">node</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">node.branch_selector</span></tt>
are defined. If the level is not zero, is recursively calls  the function
for each branch. Otherwise, it clears the selector, branches and branch
descriptions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cut_tree</span><span class="p">(</span><span class="n">tree_classifier</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_tree</span><span class="p">(</span><span class="n">tree_classifier</span><span class="p">)</span>

<span class="go">tear_rate (&lt;15.000, 4.000, 5.000&gt;)</span>
<span class="go">: normal</span>
<span class="go">   astigmatic (&lt;3.000, 4.000, 5.000&gt;)</span>
<span class="go">   : no --&gt; soft (&lt;1.000, 0.000, 5.000&gt;)</span>
<span class="go">   : yes --&gt; hard (&lt;2.000, 4.000, 0.000&gt;)</span>
<span class="go">: reduced --&gt; none (&lt;12.000, 0.000, 0.000&gt;)</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-learning-parameters">
<h4>Setting learning parameters<a class="headerlink" href="#setting-learning-parameters" title="Permalink to this headline">¶</a></h4>
<p>Let us construct a <a class="reference internal" href="#Orange.classification.tree.TreeLearner" title="Orange.classification.tree.TreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">TreeLearner</span></tt></a> to play with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">Orange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lenses</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;lenses&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">learner</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">()</span>
</pre></div>
</div>
<p>There are three crucial components in learning: the
<a class="reference internal" href="#Orange.classification.tree.TreeLearner.split" title="Orange.classification.tree.TreeLearner.split"><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt></a> and <a class="reference internal" href="#Orange.classification.tree.TreeLearner.stop" title="Orange.classification.tree.TreeLearner.stop"><tt class="xref py py-obj docutils literal"><span class="pre">stop</span></tt></a> criteria, and the
example <a class="reference internal" href="#Orange.classification.tree.TreeLearner.splitter" title="Orange.classification.tree.TreeLearner.splitter"><tt class="xref py py-obj docutils literal"><span class="pre">splitter</span></tt></a>. The default <tt class="docutils literal"><span class="pre">stop</span></tt> is set with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">learner</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">StopCriteria_common</span><span class="p">()</span>
</pre></div>
</div>
<p>The default stopping parameters are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">learner</span><span class="o">.</span><span class="n">stop</span><span class="o">.</span><span class="n">max_majority</span><span class="p">,</span> <span class="n">learner</span><span class="o">.</span><span class="n">stop</span><span class="o">.</span><span class="n">min_examples</span>
<span class="go">1.0 0.0</span>
</pre></div>
</div>
<p>The defaults only stop splitting when no instances are left or all of
them are in the same class.</p>
<p>If the minimal subset that is allowed to be split further is set to five
instances, the resulting tree is smaller.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">learner</span><span class="o">.</span><span class="n">stop</span><span class="o">.</span><span class="n">min_examples</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">learner</span><span class="p">(</span><span class="n">lenses</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span>
<span class="go">tear_rate=reduced: none (100.00%)</span>
<span class="go">tear_rate=normal</span>
<span class="go">|    astigmatic=no</span>
<span class="go">|    |    age=pre-presbyopic: soft (100.00%)</span>
<span class="go">|    |    age=presbyopic: none (50.00%)</span>
<span class="go">|    |    age=young: soft (100.00%)</span>
<span class="go">|    astigmatic=yes</span>
<span class="go">|    |    prescription=hypermetrope: none (66.67%)</span>
<span class="go">|    |    prescription=myope: hard (100.00%)</span>
</pre></div>
</div>
<p>We can also limit the maximal proportion of majority class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">learner</span><span class="o">.</span><span class="n">stop</span><span class="o">.</span><span class="n">max_majority</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">learner</span><span class="p">(</span><span class="n">lenses</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span>
<span class="go">none (62.50%)</span>
</pre></div>
</div>
</div>
<div class="section" id="redefining-tree-induction-components">
<h4>Redefining tree induction components<a class="headerlink" href="#redefining-tree-induction-components" title="Permalink to this headline">¶</a></h4>
<p>This example shows how to use a custom stop function.  First, the
<tt class="docutils literal"><span class="pre">def_stop</span></tt> function defines the default stop function. The first tree
has some added randomness; the induction also stops in 20% of the
cases when <tt class="docutils literal"><span class="pre">def_stop</span></tt> returns False. The stopping criteria for the
second tree is completely random: it stops induction in 20% of cases.
Note that in the second case lambda function still has three parameters,
even though in does not need any, since so many are necessary
for <a class="reference internal" href="#Orange.classification.tree.TreeLearner.stop" title="Orange.classification.tree.TreeLearner.stop"><tt class="xref py py-obj docutils literal"><span class="pre">stop</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span><span class="p">,</span> <span class="n">seed</span>
<span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;iris.tab&quot;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&quot;SOME RANDOMNESS IN STOPING:&quot;</span>
<span class="n">def_stop</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">StopCriteria</span><span class="p">()</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">examples</span><span class="p">,</span> <span class="n">weightID</span><span class="p">,</span> <span class="n">contingency</span><span class="p">:</span> <span class="n">def_stop</span><span class="p">(</span><span class="n">examples</span><span class="p">,</span> <span class="n">weightID</span><span class="p">,</span> <span class="n">contingency</span><span class="p">)</span> <span class="ow">or</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">iris</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span> <span class="n">l</span>

<span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">RANDOM STOPING:&quot;</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">iris</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span> <span class="n">l</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="learner-and-classifier-components">
<h3>Learner and Classifier Components<a class="headerlink" href="#learner-and-classifier-components" title="Permalink to this headline">¶</a></h3>
<div class="section" id="split-constructors">
<h4>Split constructors<a class="headerlink" href="#split-constructors" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide how to divide learning instances, ie. define branching criteria.</p>
<p>The <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a> should use the domain
contingency when possible, both for speed and adaptability.
Sometimes domain contingency does
not suffice, for example if ReliefF score is used.</p>
<p>A <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a> can veto further tree induction by returning
no classifier. This is generally related to the number of learning
instances that would go in each branch. If there are no splits with
more than <a class="reference internal" href="#Orange.classification.tree.SplitConstructor.min_subset" title="Orange.classification.tree.SplitConstructor.min_subset"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor.min_subset</span></tt></a> instances in the branches
(null nodes are allowed), the induction is stopped.</p>
<p>Split constructors that cannot handle a particular feature
type (discrete, continuous) quietly skip them. When in doubt, use
<a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Combined" title="Orange.classification.tree.SplitConstructor_Combined"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor_Combined</span></tt></a>, which delegates features to
specialized split constructors.</p>
<p>The same split constructors can be used both for classification and
regression, if the chosen score (for <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score" title="Orange.classification.tree.SplitConstructor_Score"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor_Score</span></tt></a>
and derived classes) supports both.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.SplitConstructor.min_subset">
<tt class="descname">min_subset</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor.min_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimal (weighted) number in non-null leaves.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.SplitConstructor.__call__">
<tt class="descname">__call__</tt><big>(</big><em>data</em><span class="optional">[</span>, <em>weightID</em>, <em>contingency</em>, <em>apriori_distribution</em>, <em>candidates</em>, <em>clsfr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.classification.tree.SplitConstructor.__call__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; in any acceptable form.</li>
<li><strong>weightID</strong> &#8211; Optional; the default of 0 means that all
instances have a weight of 1.0.</li>
<li><strong>contingency</strong> &#8211; a domain contingency</li>
<li><strong>apriori_distribution</strong> (<a class="reference internal" href="Orange.statistics.distribution.html#Orange.statistics.distribution.Distribution" title="Orange.statistics.distribution.Distribution"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.statistics.distribution.Distribution</span></tt></a>) &#8211; apriori class probabilities.</li>
<li><strong>candidates</strong> &#8211; only consider these
features (one boolean for each feature).</li>
<li><strong>clsfr</strong> &#8211; a node classifier (if it was constructed, that is,
if <tt class="xref py py-obj docutils literal"><span class="pre">store_node_classifier</span></tt> is True)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Construct a split. Return a tuple (<tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt>,
<tt class="xref py py-obj docutils literal"><span class="pre">branch_descriptions</span></tt> (a list), <tt class="xref py py-obj docutils literal"><span class="pre">subset_sizes</span></tt>
(the number of instances for each branch, may also be
empty), <tt class="xref py py-obj docutils literal"><span class="pre">quality</span></tt> (higher numbers mean better splits),
<tt class="xref py py-obj docutils literal"><span class="pre">spent_feature</span></tt>). If no split is constructed,
the <tt class="xref py py-obj docutils literal"><span class="pre">selector</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">branch_descriptions</span></tt> and
<tt class="xref py py-obj docutils literal"><span class="pre">subset_sizes</span></tt> are None, while <tt class="xref py py-obj docutils literal"><span class="pre">quality</span></tt> is 0.0 and
<tt class="xref py py-obj docutils literal"><span class="pre">spent_feature</span></tt> is -1.</p>
<p>If the chosen feature will be useless in the future and
should not be considered for splitting in any of the subtrees
(typically, when discrete features are used as-they-are, without
any binarization or subsetting), then it should return the index
of this feature as <tt class="xref py py-obj docutils literal"><span class="pre">spent_feature</span></tt>. If no features are spent,
<tt class="xref py py-obj docutils literal"><span class="pre">spent_feature</span></tt> is -1.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_Score">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_Score</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Score" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor</span></tt></a></p>
<p>An abstract base class that compare splits
with a <a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Score" title="Orange.feature.scoring.Score"><tt class="xref py py-class docutils literal"><span class="pre">Orange.feature.scoring.Score</span></tt></a>.  All split
constructors except for <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Combined" title="Orange.classification.tree.SplitConstructor_Combined"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor_Combined</span></tt></a> are derived
from this class.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.SplitConstructor_Score.measure">
<tt class="descname">measure</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Score.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.Score" title="Orange.feature.scoring.Score"><tt class="xref py py-class docutils literal"><span class="pre">Orange.feature.scoring.Score</span></tt></a> for split evaluation. It
has to handle the class type - for example, you cannot use
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.GainRatio" title="Orange.feature.scoring.GainRatio"><tt class="xref py py-class docutils literal"><span class="pre">GainRatio</span></tt></a> for regression or
<a class="reference internal" href="Orange.feature.scoring.html#Orange.feature.scoring.MSE" title="Orange.feature.scoring.MSE"><tt class="xref py py-class docutils literal"><span class="pre">MSE</span></tt></a> for classification.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.SplitConstructor_Score.worst_acceptable">
<tt class="descname">worst_acceptable</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Score.worst_acceptable" title="Permalink to this definition">¶</a></dt>
<dd><p>The lowest allowed split quality.  The value strongly depends
on chosen <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score.measure" title="Orange.classification.tree.SplitConstructor_Score.measure"><tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt></a> component. Default is 0.0.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_Feature">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_Feature</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score" title="Orange.classification.tree.SplitConstructor_Score"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Score</span></tt></a></p>
<p>Each value of a discrete feature corresponds to a branch.  The feature
with the highest score (<tt class="xref py py-obj docutils literal"><span class="pre">measure</span></tt>) is selected. When
tied, a random feature is selected.</p>
<p>The constructed <tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt> is an instance of
<tt class="xref py py-obj docutils literal"><span class="pre">orange.ClassifierFromVarFD</span></tt>, that returns a value of the selected
feature. <tt class="xref py py-obj docutils literal"><span class="pre">branch_description</span></tt> contains the feature&#8217;s
values. The feature is marked as spent (it cannot reappear in the
node&#8217;s subtrees).</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_ExhaustiveBinary">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_ExhaustiveBinary</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_ExhaustiveBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score" title="Orange.classification.tree.SplitConstructor_Score"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Score</span></tt></a></p>
<p>Finds the binarization with the highest score among all features. In
case of ties, a random feature is selected.</p>
<p>The constructed <tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt> is an instance
<tt class="xref py py-obj docutils literal"><span class="pre">orange.ClassifierFromVarFD</span></tt>, that returns a value of the
selected feature. Its <tt class="xref py py-obj docutils literal"><span class="pre">transformer</span></tt> contains a <tt class="docutils literal"><span class="pre">MapIntValue</span></tt>
that maps values of the feature into a binary feature. Branches
with a single feature value are described with that value and
branches with more than one are described with <tt class="docutils literal"><span class="pre">[&lt;val1&gt;,</span> <span class="pre">&lt;val2&gt;,</span>
<span class="pre">...,</span> <span class="pre">&lt;valn&gt;]</span></tt>. Only binary features are marked as spent.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_Threshold">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_Threshold</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score" title="Orange.classification.tree.SplitConstructor_Score"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Score</span></tt></a></p>
<p>The only split constructor for continuous features. It divides the
range of feature values with a threshold that maximizes the split&#8217;s
quality. In case of ties, a random feature is selected.  The feature
that yields the best binary split is returned.</p>
<p>The constructed <tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt> is an instance of
<tt class="xref py py-obj docutils literal"><span class="pre">orange.ClassifierFromVarFD</span></tt> with an attached <tt class="xref py py-obj docutils literal"><span class="pre">transformer</span></tt>,
of type <a class="reference internal" href="Orange.feature.discretization.html#Orange.feature.discretization.ThresholdDiscretizer" title="Orange.feature.discretization.ThresholdDiscretizer"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.feature.discretization.ThresholdDiscretizer</span></tt></a>. The
branch descriptions are &#8220;&lt;threshold&#8221; and &#8220;&gt;=threshold&#8221;. The feature
is not spent.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_OneAgainstOthers">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_OneAgainstOthers</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_OneAgainstOthers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Score" title="Orange.classification.tree.SplitConstructor_Score"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor_Score</span></tt></a></p>
<p>Undocumented.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.SplitConstructor_Combined">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SplitConstructor_Combined</tt><a class="headerlink" href="#Orange.classification.tree.SplitConstructor_Combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-class docutils literal"><span class="pre">SplitConstructor</span></tt></a></p>
<p>Uses different split constructors for discrete and continuous
features. Each split constructor is called with appropriate
features. Both construct a candidate for a split; the better of them
is used.</p>
<p>The choice of the split is not probabilistically fair, when
multiple candidates have the same score. For example, if there
are nine discrete features with the highest score the split
constructor for discrete features will select one of them. Now,
if there is also a single continuous feature with the same score,
<a class="reference internal" href="#Orange.classification.tree.SplitConstructor_Combined" title="Orange.classification.tree.SplitConstructor_Combined"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor_Combined</span></tt></a> would randomly select between the
proposed discrete feature and continuous feature, unaware that the
discrete feature  has already competed with eight others.  So,
the probability for selecting (each) discrete feature would be
1/18 instead of 1/10. Although incorrect, this should not affect
the performance.</p>
</dd></dl>

</div>
<div class="section" id="stopcriteria-and-stopcriteria-common">
<h4>StopCriteria and StopCriteria_common<a class="headerlink" href="#stopcriteria-and-stopcriteria-common" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#Orange.classification.tree.StopCriteria" title="Orange.classification.tree.StopCriteria"><tt class="xref py py-obj docutils literal"><span class="pre">StopCriteria</span></tt></a> determines when to stop the induction of subtrees.</p>
<dl class="class">
<dt id="Orange.classification.tree.StopCriteria">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">StopCriteria</tt><a class="headerlink" href="#Orange.classification.tree.StopCriteria" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the basic stopping criteria: the tree induction stops
when there is at most one instance left (the actual, not weighted,
number). The induction also stops when all instances are in the
same class (for discrete problems) or have the same outcome value
(for regression problems).</p>
<dl class="method">
<dt id="Orange.classification.tree.StopCriteria.__call__">
<tt class="descname">__call__</tt><big>(</big><em>instances</em><span class="optional">[</span>, <em>weightID</em>, <em>domain contingencies</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.classification.tree.StopCriteria.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True (stop) of False (continue the induction).
Contingencies are not used for counting. Derived classes should
use the contingencies whenever possible.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.StopCriteria_common">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">StopCriteria_common</tt><a class="headerlink" href="#Orange.classification.tree.StopCriteria_common" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-pruning with additional criteria.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.StopCriteria_common.max_majority">
<tt class="descname">max_majority</tt><a class="headerlink" href="#Orange.classification.tree.StopCriteria_common.max_majority" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum proportion of majority class. When exceeded,
induction stops.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.StopCriteria_common.min_instances">
<tt class="descname">min_instances</tt><a class="headerlink" href="#Orange.classification.tree.StopCriteria_common.min_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum number of instances for splitting. Subsets with less
than <a class="reference internal" href="#Orange.classification.tree.StopCriteria_common.min_instances" title="Orange.classification.tree.StopCriteria_common.min_instances"><tt class="xref py py-obj docutils literal"><span class="pre">min_instances</span></tt></a> instances are not split further.
The sample count is weighed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="splitters">
<h4>Splitters<a class="headerlink" href="#splitters" title="Permalink to this headline">¶</a></h4>
<p>Splitters sort learning instances into branches (the branches are selected
with a <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a>, while a <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a> decides the
branch for an instance during classification).</p>
<p>Most splitters call <a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">Node.branch_selector</span></tt></a> and assign
instances correspondingly. When the value is unknown they choose a
particular branch or skip the instance.</p>
<p>Some splitters can also split instances: a weighed instance is
used in more than than one subset. Each branch has a weight ID (usually,
each its own ID) and all instances in that branch should have this meta attribute.</p>
<p>An instance that
hasn&#8217;t been split has only one additional attribute (weight
ID corresponding to the subset to which it went). Instance that is split
between, say, three subsets, has three new meta attributes, one for each
subset. The weights are used only when needed; when there is no
splitting - no weight IDs are returned.</p>
<dl class="class">
<dt id="Orange.classification.tree.Splitter">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter</tt><a class="headerlink" href="#Orange.classification.tree.Splitter" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class that splits instances
into subsets.</p>
<dl class="method">
<dt id="Orange.classification.tree.Splitter.__call__">
<tt class="descname">__call__</tt><big>(</big><em>node</em>, <em>instances</em><span class="optional">[</span>, <em>weightID</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#Orange.classification.tree.Splitter.__call__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> (<a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a>) &#8211; a node.</li>
<li><strong>instances</strong> &#8211; a set of instances</li>
<li><strong>weightID</strong> &#8211; weight ID.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Use the information in <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> (particularly the
<a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a>) to split the given set of instances into
subsets.  Return a tuple with a list of instance subsets and
a list of weights.  The list of weights is either a
list of integers or None when no weights are added.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_IgnoreUnknowns">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_IgnoreUnknowns</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_IgnoreUnknowns" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Ignores the instances for which no single branch can be determined.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsToCommon">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsToCommon</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsToCommon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Places all ambiguous instances to a branch with the highest number of
instances. If there is more than one such branch, one is selected at
random and then used for all instances.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsToAll">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsToAll</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsToAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Splits instances with an unknown value of the feature into all branches.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsToRandom">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsToRandom</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsToRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Selects a random branch for ambiguous instances.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsToBranch">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsToBranch</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsToBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Constructs an additional branch for ambiguous instances.
The branch&#8217;s description is &#8220;unknown&#8221;.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsAsBranchSizes">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsAsBranchSizes</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsAsBranchSizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Splits instances with unknown value of the feature according to
proportions of instances in each branch.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Splitter_UnknownsAsSelector">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Splitter_UnknownsAsSelector</tt><a class="headerlink" href="#Orange.classification.tree.Splitter_UnknownsAsSelector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-class docutils literal"><span class="pre">Splitter</span></tt></a></p>
<p>Splits instances with unknown value of the feature according to
distribution proposed by selector (usually the same as proportions
of instances in branches).</p>
</dd></dl>

</div>
<div class="section" id="descenders">
<h4>Descenders<a class="headerlink" href="#descenders" title="Permalink to this headline">¶</a></h4>
<p>Descenders decide where should the instances that cannot be unambiguously
put in a single branch go during classification (the branches are selected
with a <a class="reference internal" href="#Orange.classification.tree.SplitConstructor" title="Orange.classification.tree.SplitConstructor"><tt class="xref py py-obj docutils literal"><span class="pre">SplitConstructor</span></tt></a>, while a <a class="reference internal" href="#Orange.classification.tree.Splitter" title="Orange.classification.tree.Splitter"><tt class="xref py py-obj docutils literal"><span class="pre">Splitter</span></tt></a> sorts instances
during learning).</p>
<dl class="class">
<dt id="Orange.classification.tree.Descender">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender</tt><a class="headerlink" href="#Orange.classification.tree.Descender" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base tree descender. It descends a
an instance as deep as possible, according to the values
of instance&#8217;s features. The <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a>: calls the node&#8217;s
<a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a> to get the branch index. If it&#8217;s a
simple index, the corresponding branch is followed. If not, the
descender decides what to do. A descender can choose a single
branch (for instance, the one that is the most recommended by the
<a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a>) or it can let the branches vote.</p>
<p>Three are possible outcomes of a descent:</p>
<ol class="arabic simple">
<li>The descender reaches a leaf. This happens when
there were no unknown or out-of-range values, or when the
descender selected a single branch and continued the descend
despite them. The descender returns the <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> it has reached.</li>
<li>Node&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a> returned a distribution and
<a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a> decided to stop the descend at this (internal)
node. It returns the current <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a>.</li>
<li>Node&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a> returned a distribution and the
<a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> wants to split the instance (i.e., to decide the class
by voting). It returns a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> and the vote-weights for
the branches.  The weights can correspond, for example,  to the
distribution returned by node&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node.branch_selector" title="Orange.classification.tree.Node.branch_selector"><tt class="xref py py-obj docutils literal"><span class="pre">branch_selector</span></tt></a>, or to
the number of learning instances that were assigned to each branch.</li>
</ol>
<dl class="method">
<dt id="Orange.classification.tree.Descender.__call__">
<tt class="descname">__call__</tt><big>(</big><em>node</em>, <em>instance</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.Descender.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Descends until it reaches a leaf or a node in
which a vote of subtrees is required. A tuple
of two elements is returned. If it reached a leaf, the tuple contains
the leaf node and None. If not, it contains a node and
a list of floats (weights of votes).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownToNode">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownToNode</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownToNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>When instance cannot be classified into a single branch, the current
node is returned. Thus, the node&#8217;s <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a>
will be used to make a decision. Therefore, internal nodes
need to have <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">Node.node_classifier</span></tt></a> defined.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownToBranch">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownToBranch</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownToBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>Classifies instances with unknown value to a special branch. This
makes sense only if the tree itself was constructed with
<a class="reference internal" href="#Orange.classification.tree.Splitter_UnknownsToBranch" title="Orange.classification.tree.Splitter_UnknownsToBranch"><tt class="xref py py-obj docutils literal"><span class="pre">Splitter_UnknownsToBranch</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownToCommonBranch">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownToCommonBranch</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownToCommonBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>Classifies instances with unknown values to the branch with the
highest number of instances. If there is more than one such branch,
random branch is chosen for each instance.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownToCommonSelector">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownToCommonSelector</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownToCommonSelector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>Classifies instances with unknown values to the branch which received
the highest recommendation by the selector.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownMergeAsBranchSizes">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownMergeAsBranchSizes</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownMergeAsBranchSizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>The subtrees vote for the instance&#8217;s class; the vote is weighted
according to the sizes of the branches.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Descender_UnknownMergeAsSelector">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Descender_UnknownMergeAsSelector</tt><a class="headerlink" href="#Orange.classification.tree.Descender_UnknownMergeAsSelector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Descender" title="Orange.classification.tree.Descender"><tt class="xref py py-obj docutils literal"><span class="pre">Descender</span></tt></a></p>
<p>The subtrees vote for the instance&#8217;s class; the vote is weighted
according to the selectors proposal.</p>
</dd></dl>

</div>
<div class="section" id="pruning">
<h4>Pruning<a class="headerlink" href="#pruning" title="Permalink to this headline">¶</a></h4>
<p id="index-2">The pruners construct a shallow copy of a tree. The pruned tree&#8217;s
<a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> contain references to the same contingency matrices,
node classifiers, branch selectors, ...  as the original tree.</p>
<p>Pruners cannot construct a new <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a>.  Thus, for
pruning, internal nodes must have <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a> defined
(the default).</p>
<dl class="class">
<dt id="Orange.classification.tree.Pruner">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Pruner</tt><a class="headerlink" href="#Orange.classification.tree.Pruner" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base tree pruner.</p>
<dl class="method">
<dt id="Orange.classification.tree.Pruner.__call__">
<tt class="descname">__call__</tt><big>(</big><em>tree</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.Pruner.__call__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tree</strong> &#8211; either
a <a class="reference internal" href="#Orange.classification.tree.Node" title="Orange.classification.tree.Node"><tt class="xref py py-obj docutils literal"><span class="pre">Node</span></tt></a> or (the C++ version of the classifier,
saved in <tt class="xref py py-obj docutils literal"><span class="pre">TreeClassfier.base_classifier</span></tt>).</td>
</tr>
</tbody>
</table>
<p>The resulting pruned tree is of the same type as the argument.
The original tree remains intact.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Pruner_SameMajority">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Pruner_SameMajority</tt><a class="headerlink" href="#Orange.classification.tree.Pruner_SameMajority" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Pruner" title="Orange.classification.tree.Pruner"><tt class="xref py py-class docutils literal"><span class="pre">Pruner</span></tt></a></p>
<p>A tree can have a subtrees where all the leaves have
the same majority class. This is allowed because leaves can still
have different class distributions and thus predict different
probabilities.  The <a class="reference internal" href="#Orange.classification.tree.Pruner_SameMajority" title="Orange.classification.tree.Pruner_SameMajority"><tt class="xref py py-obj docutils literal"><span class="pre">Pruner_SameMajority</span></tt></a> prunes the tree so
that there is no subtree in which all the nodes would have the same
majority class.</p>
<p>This pruner will only prune the nodes in which the node classifier
is a <a class="reference internal" href="Orange.classification.constant.html#Orange.classification.ConstantClassifier" title="Orange.classification.ConstantClassifier"><tt class="xref py py-obj docutils literal"><span class="pre">ConstantClassifier</span></tt></a>
(or a derived class).</p>
<p>The pruning works from leaves to the root.
It siblings have (at least one) common majority class, they can be pruned.</p>
</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.Pruner_m">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">Pruner_m</tt><a class="headerlink" href="#Orange.classification.tree.Pruner_m" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Orange.classification.tree.Pruner" title="Orange.classification.tree.Pruner"><tt class="xref py py-class docutils literal"><span class="pre">Pruner</span></tt></a></p>
<p>Prunes a tree by comparing m-estimates of static and dynamic
error as defined in (Bratko, 2002).</p>
<dl class="attribute">
<dt id="Orange.classification.tree.Pruner_m.m">
<tt class="descname">m</tt><a class="headerlink" href="#Orange.classification.tree.Pruner_m.m" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter m for m-estimation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="printing-the-tree">
<h4>Printing the tree<a class="headerlink" href="#printing-the-tree" title="Permalink to this headline">¶</a></h4>
<p>The tree printing functions are very flexible. They can print, for
example, numbers of instances, proportions of majority class in nodes
and similar, or more complex statistics like the proportion of instances
in a particular class divided by the proportion of instances of this
class in a parent node. Users may also pass their own functions to print
certain elements.</p>
<p>The easiest way to print the tree is to print <a class="reference internal" href="#Orange.classification.tree.TreeClassifier" title="Orange.classification.tree.TreeClassifier"><tt class="xref py py-func docutils literal"><span class="pre">TreeClassifier()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span>
<span class="go">petal width&lt;0.800: Iris-setosa (100.00%)</span>
<span class="go">petal width&gt;=0.800</span>
<span class="go">|    petal width&lt;1.750</span>
<span class="go">|    |    petal length&lt;5.350: Iris-versicolor (94.23%)</span>
<span class="go">|    |    petal length&gt;=5.350: Iris-virginica (100.00%)</span>
<span class="go">|    petal width&gt;=1.750</span>
<span class="go">|    |    petal length&lt;4.850: Iris-virginica (66.67%)</span>
<span class="go">|    |    petal length&gt;=4.850: Iris-virginica (100.00%)</span>
</pre></div>
</div>
<div class="section" id="format-string">
<h5>Format string<a class="headerlink" href="#format-string" title="Permalink to this headline">¶</a></h5>
<p>Format strings are printed at every leaf or internal node with the certain
format specifiers replaced by data from the tree node. Specifiers are
generally of form <strong>%[^]&lt;precision&gt;&lt;quantity&gt;&lt;divisor&gt;</strong>.</p>
<p><strong>^</strong> at the start tells that the number should be multiplied by 100,
which is useful for proportions like percentages.</p>
<p><strong>&lt;precision&gt;</strong> is in the same format as in Python (or C) string
formatting. For instance, <tt class="docutils literal"><span class="pre">%N</span></tt> denotes the number of instances in
the node, hence <tt class="docutils literal"><span class="pre">%6.2N</span></tt> would mean output to two decimal digits
and six places altogether. If left out, a default format <tt class="docutils literal"><span class="pre">5.3</span></tt> is
used, unless the numbers are multiplied by 100, in which case the default
is <tt class="docutils literal"><span class="pre">.0</span></tt> (no decimals, the number is rounded to the nearest integer).</p>
<p><strong>&lt;divisor&gt;</strong> tells what to divide the quantity in that node with.
<tt class="docutils literal"><span class="pre">bP</span></tt> means division by the same quantity in the parent node; for instance,
<tt class="docutils literal"><span class="pre">%NbP</span></tt> gives the number of instances in the node divided by the
number of instances in parent node. Precision formatting can be added,
e.g. <tt class="docutils literal"><span class="pre">%6.2NbP</span></tt>. <tt class="docutils literal"><span class="pre">bA</span></tt> denotes division by the same quantity over the entire
data set, so <tt class="docutils literal"><span class="pre">%NbA</span></tt> will tell you the proportion of instances (out
of the entire training data set) that fell into that node. If division is
impossible since the parent node does not exist or some data is missing,
a dot is printed out instead.</p>
<p><strong>&lt;quantity&gt;</strong> defines what to print and is the only required element.
It can be:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">V</span></tt></dt>
<dd>The predicted value at that node. Precision
or divisor can not be defined here.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>The number of instances in the node.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>The number of instances in the majority class (that is, the class
predicted by the node).</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd>The proportion of instances in the majority class.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>The average class for instances the node; this is available only for
regression trees.</dd>
<dt><tt class="docutils literal"><span class="pre">E</span></tt></dt>
<dd>Standard error for class of instances in the node; available only for
regression trees.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Print out the confidence interval. The modifier is used as
<tt class="docutils literal"><span class="pre">%I(95)</span></tt> of (more complicated) <tt class="docutils literal"><span class="pre">%5.3I(95)bP</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd><p class="first">The number of instances in the given class.  For a classification
example, <tt class="docutils literal"><span class="pre">%5.3C=&quot;Iris-virginica&quot;bP</span></tt> denotes the number of instances
of Iris-virginica by the number of instances this class in the parent
node ( instances that are <em>not</em> Iris-virginica could be described with
<tt class="docutils literal"><span class="pre">%5.3CbP!=&quot;Iris-virginica&quot;</span></tt>).</p>
<p class="last">For regression trees, use operators =, !=, &lt;, &lt;=, &gt;, and &gt;=, as in
<tt class="docutils literal"><span class="pre">%C&lt;22</span></tt>, with optional precision and divisor. Intervals are also
possible: <tt class="docutils literal"><span class="pre">%C[20,</span> <span class="pre">22]</span></tt> gives the number of instances between
20 and 22 (inclusive) and <tt class="docutils literal"><span class="pre">%C(20,</span> <span class="pre">22)</span></tt> gives the number of such
instances excluding the boundaries. Mixing of parentheses is allowed,
e.g. <tt class="docutils literal"><span class="pre">%C(20,</span> <span class="pre">22]</span></tt>.  Add <tt class="docutils literal"><span class="pre">!</span></tt> for instances outside the interval,
like <tt class="docutils literal"><span class="pre">%C!(20,</span> <span class="pre">22]</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Same as <tt class="docutils literal"><span class="pre">C</span></tt>, except that it computes the proportion of the class
instead of the number of instances.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>The number of instances in each class. Precision and the divisor
are applied to each number in the distribution.  This quantity can
not be computed for regression trees.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Same as <tt class="docutils literal"><span class="pre">D</span></tt>, except that it shows proportions of instances.</dd>
<dt>&lt;user defined formats&gt;</dt>
<dd>Instructions and examples of added formats are at the end of this
section.</dd>
</dl>
<p class="rubric">Examples on classification trees</p>
<p>A tree on the iris data set with the depth limited to three
levels is built as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;iris&quot;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">iris</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Printing the predicted class at each node, the number
of instances in the majority class with the total number of instances in
the node requires a custom format string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%V (%M out of %N)&quot;</span><span class="p">)</span>
<span class="go">petal width&lt;0.800: Iris-setosa (50.000 out of 50.000)</span>
<span class="go">petal width&gt;=0.800</span>
<span class="go">|    petal width&lt;1.750</span>
<span class="go">|    |    petal length&lt;5.350: Iris-versicolor (49.000 out of 52.000)</span>
<span class="go">|    |    petal length&gt;=5.350: Iris-virginica (2.000 out of 2.000)</span>
<span class="go">|    petal width&gt;=1.750</span>
<span class="go">|    |    petal length&lt;4.850: Iris-virginica (2.000 out of 3.000)</span>
<span class="go">|    |    petal length&gt;=4.850: Iris-virginica (43.000 out of 43.000)</span>
</pre></div>
</div>
<p>The number of instances as
compared to the entire data set and to the parent node:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%V (%^MbA%, %^MbP%)&quot;</span><span class="p">)</span>
<span class="go">petal width&lt;0.800: Iris-setosa (100%, 100%)</span>
<span class="go">petal width&gt;=0.800</span>
<span class="go">|    petal width&lt;1.750</span>
<span class="go">|    |    petal length&lt;5.350: Iris-versicolor (98%, 100%)</span>
<span class="go">|    |    petal length&gt;=5.350: Iris-virginica (4%, 40%)</span>
<span class="go">|    petal width&gt;=1.750</span>
<span class="go">|    |    petal length&lt;4.850: Iris-virginica (4%, 4%)</span>
<span class="go">|    |    petal length&gt;=4.850: Iris-virginica (86%, 96%)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">%M</span></tt> is the number of instances in the majority class. Dividing by
the number of all instances from this class on the entire data set
is described with <tt class="docutils literal"><span class="pre">%MbA</span></tt>. Add <tt class="docutils literal"><span class="pre">^</span></tt> in front for mutiplication with
100. The percent sign <em>after</em> that is printed out literally, just as the
comma and parentheses. For the proportion of this class in the parent the
<tt class="docutils literal"><span class="pre">bA</span></tt> is replaced with <tt class="docutils literal"><span class="pre">bA</span></tt>.</p>
<p>To print the number of versicolors in each node, together with the
proportion of versicolors among the instances in this particular node
and among all versicolors, use the following:</p>
<div class="highlight-python"><pre>'%C="Iris-versicolor" (%^c="Iris-versicolor"% of node, %^CbA="Iris-versicolor"% of versicolors)</pre>
</div>
<p>It gives:</p>
<div class="highlight-python"><pre>petal width&lt;0.800: 0.000 (0% of node, 0% of versicolors)
petal width&gt;=0.800
|    petal width&lt;1.750
|    |    petal length&lt;5.350: 49.000 (94% of node, 98% of versicolors)
|    |    petal length&gt;=5.350: 0.000 (0% of node, 0% of versicolors)
|    petal width&gt;=1.750
|    |    petal length&lt;4.850: 1.000 (33% of node, 2% of versicolors)
|    |    petal length&gt;=4.850: 0.000 (0% of node, 0% of versicolors)</pre>
</div>
<p>Finally, to print the distributions using a format string <tt class="docutils literal"><span class="pre">%D</span></tt>:</p>
<div class="highlight-python"><pre>petal width&lt;0.800: [50.000, 0.000, 0.000]
petal width&gt;=0.800
|    petal width&lt;1.750
|    |    petal length&lt;5.350: [0.000, 49.000, 3.000]
|    |    petal length&gt;=5.350: [0.000, 0.000, 2.000]
|    petal width&gt;=1.750
|    |    petal length&lt;4.850: [0.000, 1.000, 2.000]
|    |    petal length&gt;=4.850: [0.000, 0.000, 43.000]</pre>
</div>
<p>As the order of classes is the same as in <tt class="docutils literal"><span class="pre">data.domain.class_var.values</span></tt>
(setosa, versicolor, virginica), there are 49 versicolors and 3 virginicae
in the node at <tt class="docutils literal"><span class="pre">petal</span> <span class="pre">length&lt;5.350</span></tt>. To print the proportions within
nodes rounded to two decimals use <tt class="docutils literal"><span class="pre">%.2d</span></tt>:</p>
<div class="highlight-python"><pre>petal width&lt;0.800: [1.00, 0.00, 0.00]
petal width&gt;=0.800
|    petal width&lt;1.750
|    |    petal length&lt;5.350: [0.00, 0.94, 0.06]
|    |    petal length&gt;=5.350: [0.00, 0.00, 1.00]
|    petal width&gt;=1.750
|    |    petal length&lt;4.850: [0.00, 0.33, 0.67]
|    |    petal length&gt;=4.850: [0.00, 0.00, 1.00]</pre>
</div>
<p>The most trivial format string for internal nodes is for printing
node predictions. <tt class="docutils literal"><span class="pre">.</span></tt> in the following example specifies
that the node_str should be the same as leaf_str.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%V&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The output:</p>
<div class="highlight-python"><pre>root: Iris-setosa
|    petal width&lt;0.800: Iris-setosa
|    petal width&gt;=0.800: Iris-versicolor
|    |    petal width&lt;1.750: Iris-versicolor
|    |    |    petal length&lt;5.350: Iris-versicolor
|    |    |    petal length&gt;=5.350: Iris-virginica
|    |    petal width&gt;=1.750: Iris-virginica
|    |    |    petal length&lt;4.850: Iris-virginica
|    |    |    petal length&gt;=4.850: Iris-virginica</pre>
</div>
<p>A node <em>root</em> has appeared and the tree looks one level
deeper. This is needed to also print the data for tree root.</p>
<p>To observe how the number
of virginicas decreases down the tree try:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&#39;%^.1CbA=&quot;Iris-virginica&quot;% (%^.1CbP=&quot;Iris-virginica&quot;%)&#39;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Interpretation: <tt class="docutils literal"><span class="pre">CbA=&quot;Iris-virginica&quot;</span></tt> is
the number of instances from virginica, divided by the total number
of instances in this class. Add <tt class="docutils literal"><span class="pre">^.1</span></tt> and the result will be
multiplied and printed with one decimal. The trailing <tt class="docutils literal"><span class="pre">%</span></tt> is printed
out. In parentheses the same thing was divided by
the instances in the parent node. The single quotes were used for strings, so
that double quotes inside the string can specify the class.</p>
<div class="highlight-python"><pre>root: 100.0% (.%)
|    petal width&lt;0.800: 0.0% (0.0%)
|    petal width&gt;=0.800: 100.0% (100.0%)
|    |    petal width&lt;1.750: 10.0% (10.0%)
|    |    |    petal length&lt;5.350: 6.0% (60.0%)
|    |    |    petal length&gt;=5.350: 4.0% (40.0%)
|    |    petal width&gt;=1.750: 90.0% (90.0%)
|    |    |    petal length&lt;4.850: 4.0% (4.4%)
|    |    |    petal length&gt;=4.850: 86.0% (95.6%)</pre>
</div>
<p>If <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.to_string" title="Orange.classification.tree.TreeClassifier.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a> cannot compute something, in this case
because the root has no parent, it prints out a dot.</p>
<p>The final example with classification trees prints the distributions in
nodes, the distribution compared to the parent, the proportions compared
to the parent and the predicted class in the leaves:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&#39;&quot;%V   %D %.2DbP </span><span class="si">%.2d</span><span class="s">bP&quot;&#39;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&#39;&quot;%D %.2DbP </span><span class="si">%.2d</span><span class="s">bP&quot;&#39;</span><span class="p">)</span>
<span class="go">root: [50.000, 50.000, 50.000] . .</span>
<span class="go">|    petal width&lt;0.800: [50.000, 0.000, 0.000] [1.00, 0.00, 0.00] [3.00, 0.00, 0.00]:</span>
<span class="go">|        Iris-setosa   [50.000, 0.000, 0.000] [1.00, 0.00, 0.00] [3.00, 0.00, 0.00]</span>
<span class="go">|    petal width&gt;=0.800: [0.000, 50.000, 50.000] [0.00, 1.00, 1.00] [0.00, 1.50, 1.50]</span>
<span class="go">|    |    petal width&lt;1.750: [0.000, 49.000, 5.000] [0.00, 0.98, 0.10] [0.00, 1.81, 0.19]</span>
<span class="go">|    |    |    petal length&lt;5.350: [0.000, 49.000, 3.000] [0.00, 1.00, 0.60] [0.00, 1.04, 0.62]:</span>
<span class="go">|    |    |        Iris-versicolor   [0.000, 49.000, 3.000] [0.00, 1.00, 0.60] [0.00, 1.04, 0.62]</span>
<span class="go">|    |    |    petal length&gt;=5.350: [0.000, 0.000, 2.000] [0.00, 0.00, 0.40] [0.00, 0.00, 10.80]:</span>
<span class="go">|    |    |        Iris-virginica   [0.000, 0.000, 2.000] [0.00, 0.00, 0.40] [0.00, 0.00, 10.80]</span>
<span class="go">|    |    petal width&gt;=1.750: [0.000, 1.000, 45.000] [0.00, 0.02, 0.90] [0.00, 0.04, 1.96]</span>
<span class="go">|    |    |    petal length&lt;4.850: [0.000, 1.000, 2.000] [0.00, 1.00, 0.04] [0.00, 15.33, 0.68]:</span>
<span class="go">|    |    |        Iris-virginica   [0.000, 1.000, 2.000] [0.00, 1.00, 0.04] [0.00, 15.33, 0.68]</span>
<span class="go">|    |    |    petal length&gt;=4.850: [0.000, 0.000, 43.000] [0.00, 0.00, 0.96] [0.00, 0.00, 1.02]:</span>
<span class="go">|    |    |        Iris-virginica   [0.000, 0.000, 43.000] [0.00, 0.00, 0.96] [0.00, 0.00, 1.02]</span>
</pre></div>
</div>
<p class="rubric">Examples on regression trees</p>
<p>The regression trees examples use a tree induced from the housing data
set. Without other argumets, <a class="reference internal" href="#Orange.classification.tree.TreeClassifier.to_string" title="Orange.classification.tree.TreeClassifier.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">TreeClassifier.to_string()</span></tt></a> prints the
following:</p>
<div class="highlight-python"><pre>RM&lt;6.941
|    LSTAT&lt;14.400
|    |    DIS&lt;1.385: 45.6
|    |    DIS&gt;=1.385: 22.9
|    LSTAT&gt;=14.400
|    |    CRIM&lt;6.992: 17.1
|    |    CRIM&gt;=6.992: 12.0
RM&gt;=6.941
|    RM&lt;7.437
|    |    CRIM&lt;7.393: 33.3
|    |    CRIM&gt;=7.393: 14.4
|    RM&gt;=7.437
|    |    TAX&lt;534.500: 45.9
|    |    TAX&gt;=534.500: 21.9</pre>
</div>
<p>To add the standard error in both internal nodes and leaves, and
the 90% confidence intervals in the leaves, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;[SE: </span><span class="si">%E</span><span class="s">]</span><span class="se">\t</span><span class="s"> %V %I(90)&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&quot;[SE: </span><span class="si">%E</span><span class="s">]&quot;</span><span class="p">)</span>
<span class="go">root: [SE: 0.409]</span>
<span class="go">|    RM&lt;6.941: [SE: 0.306]</span>
<span class="go">|    |    LSTAT&lt;14.400: [SE: 0.320]</span>
<span class="go">|    |    |    DIS&lt;1.385: [SE: 4.420]:</span>
<span class="go">|    |    |        [SE: 4.420]   45.6 [38.331-52.829]</span>
<span class="go">|    |    |    DIS&gt;=1.385: [SE: 0.244]:</span>
<span class="go">|    |    |        [SE: 0.244]   22.9 [22.504-23.306]</span>
<span class="go">|    |    LSTAT&gt;=14.400: [SE: 0.333]</span>
<span class="go">|    |    |    CRIM&lt;6.992: [SE: 0.338]:</span>
<span class="go">|    |    |        [SE: 0.338]   17.1 [16.584-17.691]</span>
<span class="go">|    |    |    CRIM&gt;=6.992: [SE: 0.448]:</span>
<span class="go">|    |    |        [SE: 0.448]   12.0 [11.243-12.714]</span>
<span class="go">|    RM&gt;=6.941: [SE: 1.031]</span>
<span class="go">|    |    RM&lt;7.437: [SE: 0.958]</span>
<span class="go">|    |    |    CRIM&lt;7.393: [SE: 0.692]:</span>
<span class="go">|    |    |        [SE: 0.692]   33.3 [32.214-34.484]</span>
<span class="go">|    |    |    CRIM&gt;=7.393: [SE: 2.157]:</span>
<span class="go">|    |    |        [SE: 2.157]   14.4 [10.862-17.938]</span>
<span class="go">|    |    RM&gt;=7.437: [SE: 1.124]</span>
<span class="go">|    |    |    TAX&lt;534.500: [SE: 0.817]:</span>
<span class="go">|    |    |        [SE: 0.817]   45.9 [44.556-47.237]</span>
<span class="go">|    |    |    TAX&gt;=534.500: [SE: 0.000]:</span>
<span class="go">|    |    |        [SE: 0.000]   21.9 [21.900-21.900]</span>
</pre></div>
</div>
<p>The predicted value (<tt class="docutils literal"><span class="pre">%V</span></tt>) and the average (<tt class="docutils literal"><span class="pre">%A</span></tt>) may differ because
a regression tree does not always predict the leaf average, but whatever
the <a class="reference internal" href="#Orange.classification.tree.Node.node_classifier" title="Orange.classification.tree.Node.node_classifier"><tt class="xref py py-obj docutils literal"><span class="pre">node_classifier</span></tt></a> in a leaf returns.  As <tt class="docutils literal"><span class="pre">%V</span></tt> uses the
<a class="reference internal" href="Orange.feature.descriptor.html#Orange.feature.Continuous" title="Orange.feature.Continuous"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.feature.Continuous</span></tt></a>&#8216; function for printing the
value, the number has the same number of decimals as in the data file.</p>
<p>Regression trees cannot print the distributions in the same way
as classification trees. They instead offer a set of operators for
observing the number of instances within a certain range. For instance,
to print the number of instances with values below 22 and compare
it with values in the parent nodes use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%C&lt;22 (</span><span class="si">%c</span><span class="s">bP&lt;22)&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
<span class="go">root: 277.000 (.)</span>
<span class="go">|    RM&lt;6.941: 273.000 (1.160)</span>
<span class="go">|    |    LSTAT&lt;14.400: 107.000 (0.661)</span>
<span class="go">|    |    |    DIS&lt;1.385: 0.000 (0.000)</span>
<span class="go">|    |    |    DIS&gt;=1.385: 107.000 (1.020)</span>
<span class="go">|    |    LSTAT&gt;=14.400: 166.000 (1.494)</span>
<span class="go">|    |    |    CRIM&lt;6.992: 93.000 (0.971)</span>
<span class="go">|    |    |    CRIM&gt;=6.992: 73.000 (1.040)</span>
<span class="go">|    RM&gt;=6.941: 4.000 (0.096)</span>
<span class="go">|    |    RM&lt;7.437: 3.000 (1.239)</span>
<span class="go">|    |    |    CRIM&lt;7.393: 0.000 (0.000)</span>
<span class="go">|    |    |    CRIM&gt;=7.393: 3.000 (15.333)</span>
<span class="go">|    |    RM&gt;=7.437: 1.000 (0.633)</span>
<span class="go">|    |    |    TAX&lt;534.500: 0.000 (0.000)</span>
<span class="go">|    |    |    TAX&gt;=534.500: 1.000 (30.000)&lt;/xmp&gt;</span>
</pre></div>
</div>
<p>The last line, for instance, says the the number of instances with the
class below 22 is among those with tax above 534 is 30 times higher than
the number of such instances in its parent node.</p>
<p>To count the same for all instances <em>outside</em>
interval [20, 22] and print out the proportions as percents use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%C![20,22] (%^cbP![20,22]%)&quot;</span><span class="p">,</span> <span class="n">node_str</span><span class="o">=</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The format string  <tt class="docutils literal"><span class="pre">%c![20,</span> <span class="pre">22]</span></tt> denotes the proportion of instances
(within the node) whose values are below 20 or above 22. <tt class="docutils literal"><span class="pre">%cbP![20,</span>
<span class="pre">22]</span></tt> derives same statistics computed on the parent. A <tt class="docutils literal"><span class="pre">^</span></tt> is added
for percentages.</p>
<div class="highlight-python"><pre>root: 439.000 (.%)
|    RM&lt;6.941: 364.000 (98%)
|    |    LSTAT&lt;14.400: 200.000 (93%)
|    |    |    DIS&lt;1.385: 5.000 (127%)
|    |    |    DIS&gt;=1.385: 195.000 (99%)
|    |    LSTAT&gt;=14.400: 164.000 (111%)
|    |    |    CRIM&lt;6.992: 91.000 (96%)
|    |    |    CRIM&gt;=6.992: 73.000 (105%)
|    RM&gt;=6.941: 75.000 (114%)
|    |    RM&lt;7.437: 46.000 (101%)
|    |    |    CRIM&lt;7.393: 43.000 (100%)
|    |    |    CRIM&gt;=7.393: 3.000 (100%)
|    |    RM&gt;=7.437: 29.000 (98%)
|    |    |    TAX&lt;534.500: 29.000 (103%)
|    |    |    TAX&gt;=534.500: 0.000 (0%)</pre>
</div>
</div>
<div class="section" id="defining-custom-printouts">
<h5>Defining custom printouts<a class="headerlink" href="#defining-custom-printouts" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#Orange.classification.tree.TreeClassifier.to_string" title="Orange.classification.tree.TreeClassifier.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">TreeClassifier.to_string()</span></tt></a>&#8216;s argument <tt class="xref py py-obj docutils literal"><span class="pre">user_formats</span></tt> can be used to
print other information.  <tt class="xref py py-obj docutils literal"><span class="pre">user_formats</span></tt> should
contain a list of tuples with a regular expression and a function to be
called when that expression is found in the format string. Expressions
from <tt class="xref py py-obj docutils literal"><span class="pre">user_formats</span></tt> are checked before the built-in expressions
discussed above.</p>
<p>The regular expression should describe a string like used above,
for instance <tt class="docutils literal"><span class="pre">%.2DbP</span></tt>. When a leaf or internal node
is printed, the format string (<tt class="xref py py-obj docutils literal"><span class="pre">leaf_str</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">node_str</span></tt>)
is checked for these regular expressions and when the match is found,
the corresponding callback function is called.</p>
<p>The passed function will get five arguments: the format string
(<tt class="xref py py-obj docutils literal"><span class="pre">leaf_str</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">node_str</span></tt>), the match object, the node which is
being printed, its parent (can be None) and the tree classifier.
The function should return the format string in which the part described
by the match object (that is, the part that is matched by the regular
expression) is replaced by whatever information your callback function
is supposed to give.</p>
<p>The function can use several utility function provided in the module.</p>
<dl class="function">
<dt id="Orange.classification.tree.insert_str">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">insert_str</tt><big>(</big><em>s</em>, <em>mo</em>, <em>sub</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.insert_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the part of s which is covered by mo 
with the string sub.</p>
</dd></dl>

<dl class="function">
<dt id="Orange.classification.tree.insert_dot">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">insert_dot</tt><big>(</big><em>s</em>, <em>mo</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.insert_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the part of s which is covered by mo 
with a dot.  You should use this when the 
function cannot compute the desired quantity; it is called, for instance, 
when it needs to divide by something in the parent, but the parent 
doesn&#8217;t exist.</p>
</dd></dl>

<dl class="function">
<dt id="Orange.classification.tree.insert_num">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">insert_num</tt><big>(</big><em>s</em>, <em>mo</em>, <em>n</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.insert_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the part of s matched by mo with the number n, 
formatted as specified by the user, that is, it multiplies 
it by 100, if needed, and prints with the right number of 
places and decimals. It does so by checking the mo
for a group named m100 (representing the <tt class="docutils literal"><span class="pre">^</span></tt> in the format string) 
and a group named fs representing the part giving the number o
f decimals (e.g. <tt class="docutils literal"><span class="pre">5.3</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="Orange.classification.tree.by_whom">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">by_whom</tt><big>(</big><em>by</em>, <em>parent</em>, <em>tree</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.by_whom" title="Permalink to this definition">¶</a></dt>
<dd><p>If by equals bp, return parent, else return
<tt class="docutils literal"><span class="pre">tree.tree</span></tt>. This is used to find what to divide the quantity 
with, when division is required.</p>
</dd></dl>

<p>The module also includes reusable regular expressions:</p>
<dl class="data">
<dt id="Orange.classification.tree.fs">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">fs</tt><em class="property"> = '(?P&lt;m100&gt;\\^?)(?P&lt;fs&gt;(\\d*\\.?\\d*)?)'</em><a class="headerlink" href="#Orange.classification.tree.fs" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the multiplier by 100 (<tt class="docutils literal"><span class="pre">^</span></tt>) and the format
for the number of decimals (e.g. <tt class="docutils literal"><span class="pre">5.3</span></tt>). The corresponding
groups are named <tt class="docutils literal"><span class="pre">m100</span></tt> and <tt class="docutils literal"><span class="pre">fs</span></tt>.</p>
</dd></dl>

<dl class="data">
<dt id="Orange.classification.tree.by">
<tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">by</tt><em class="property"> = '(?P&lt;by&gt;(b(P|A)))?'</em><a class="headerlink" href="#Orange.classification.tree.by" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines bP or bA or nothing; the result is in groups by.</p>
</dd></dl>

<p>For a trivial example, <tt class="docutils literal"><span class="pre">%V</span></tt> is implemented with the
following tuple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;%V&quot;</span><span class="p">),</span> <span class="n">replaceV</span><span class="p">)</span>
</pre></div>
</div>
<p>And <tt class="docutils literal"><span class="pre">replaceV</span></tt> is defined by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">replaceV</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">insert_str</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">node_classifier</span><span class="o">.</span><span class="n">default_value</span><span class="p">))</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">replaceV</span></tt> takes the value predicted at the node
(<tt class="docutils literal"><span class="pre">node.node_classifier.default_value</span></tt> ), converts it to a string
and passes it to <a class="reference internal" href="#Orange.classification.tree.insert_str" title="Orange.classification.tree.insert_str"><tt class="xref py py-func docutils literal"><span class="pre">insert_str()</span></tt></a>.</p>
<p>A more complex regular expression is the one for the proportion of
majority class, defined as <tt class="docutils literal"><span class="pre">&quot;%&quot;+fs+&quot;M&quot;+by</span></tt>. It uses the two partial
expressions defined above (<a class="reference internal" href="#Orange.classification.tree.fs" title="Orange.classification.tree.fs"><tt class="xref py py-obj docutils literal"><span class="pre">fs</span></tt></a> and <a class="reference internal" href="#Orange.classification.tree.by" title="Orange.classification.tree.by"><tt class="xref py py-obj docutils literal"><span class="pre">by</span></tt></a>).</p>
<p>The following code prints the classification margin for each node,
that is, the difference between the proportion of the largest and the
second largest class in the node:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_margin</span><span class="p">(</span><span class="n">dist</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">abs</span> <span class="o">&lt;</span> <span class="mf">1e-30</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist</span><span class="o">.</span><span class="n">abs</span>

<span class="k">def</span> <span class="nf">replaceB</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">get_margin</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">distribution</span><span class="p">)</span>

    <span class="n">by</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&quot;by&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">margin</span> <span class="ow">and</span> <span class="n">by</span><span class="p">:</span>
        <span class="n">whom</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">by_whom</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">whom</span> <span class="ow">and</span> <span class="n">whom</span><span class="o">.</span><span class="n">distribution</span><span class="p">:</span>
            <span class="n">div_margin</span> <span class="o">=</span> <span class="n">get_margin</span><span class="p">(</span><span class="n">whom</span><span class="o">.</span><span class="n">distribution</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">div_margin</span> <span class="o">&gt;</span> <span class="mf">1e-30</span><span class="p">:</span>
                <span class="n">margin</span> <span class="o">/=</span> <span class="n">div_margin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert_dot</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert_dot</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">insert_num</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="n">margin</span><span class="p">)</span>

<span class="n">my_format</span> <span class="o">=</span> <span class="p">[(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;%&quot;</span> <span class="o">+</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">fs</span>
    <span class="o">+</span> <span class="s">&quot;B&quot;</span> <span class="o">+</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">by</span><span class="p">),</span> <span class="n">replaceB</span><span class="p">)]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">get_margin</span></tt> computes the margin from the distribution. The replacing
function, <tt class="docutils literal"><span class="pre">replaceB</span></tt>, computes the margin for the node.  If <a class="reference internal" href="#Orange.classification.tree.by" title="Orange.classification.tree.by"><tt class="xref py py-data docutils literal"><span class="pre">by</span></tt></a>
group is present, we call <a class="reference internal" href="#Orange.classification.tree.by_whom" title="Orange.classification.tree.by_whom"><tt class="xref py py-func docutils literal"><span class="pre">by_whom()</span></tt></a> to get the node with whose
margin this node&#8217;s margin is to be divided. If this node (usually the
parent) does not exist of if its margin is zero, <a class="reference internal" href="#Orange.classification.tree.insert_dot" title="Orange.classification.tree.insert_dot"><tt class="xref py py-func docutils literal"><span class="pre">insert_dot()</span></tt></a>
inserts dot, otherwise <a class="reference internal" href="#Orange.classification.tree.insert_num" title="Orange.classification.tree.insert_num"><tt class="xref py py-func docutils literal"><span class="pre">insert_num()</span></tt></a> is called which inserts the
number in the user-specified format.  <tt class="docutils literal"><span class="pre">my_format</span></tt> contains the regular
expression and the callback function.</p>
<p>Printing the tree with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">tree</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">leaf_str</span><span class="o">=</span><span class="s">&quot;%V %^B% (%^3.2BbP%)&quot;</span><span class="p">,</span> <span class="n">user_formats</span><span class="o">=</span><span class="n">my_format</span><span class="p">)</span>
</pre></div>
</div>
<p>yields:</p>
<div class="highlight-python"><pre>petal width&lt;0.800: Iris-setosa 100% (100.00%)
petal width&gt;=0.800
|    petal width&lt;1.750
|    |    petal length&lt;5.350: Iris-versicolor 88% (108.57%)
|    |    petal length&gt;=5.350: Iris-virginica 100% (122.73%)
|    petal width&gt;=1.750
|    |    petal length&lt;4.850: Iris-virginica 33% (34.85%)
|    |    petal length&gt;=4.850: Iris-virginica 100% (104.55%)</pre>
</div>
</div>
<div class="section" id="plotting-with-dot">
<h5>Plotting with Dot<a class="headerlink" href="#plotting-with-dot" title="Permalink to this headline">¶</a></h5>
<p>To produce images of trees, first create a .dot file with
<a class="reference internal" href="#Orange.classification.tree.TreeClassifier.dot" title="Orange.classification.tree.TreeClassifier.dot"><tt class="xref py py-meth docutils literal"><span class="pre">TreeClassifier.dot()</span></tt></a>. If it was saved to &#8220;tree5.dot&#8221;, plot a gif
with the following command:</p>
<div class="highlight-python"><pre>dot -Tgif tree5.dot -otree5.gif</pre>
</div>
<p>Check GraphViz&#8217;s dot documentation for more options and
output formats.</p>
</div>
</div>
</div>
</div>
<div class="section" id="c4-5-tree-inducer">
<h2>C4.5 Tree Inducer<a class="headerlink" href="#c4-5-tree-inducer" title="Permalink to this headline">¶</a></h2>
<p>C4.5 is, as  a standard benchmark in machine learning, incorporated in
Orange. The implementation uses the original C4.5 code, so the resulting
tree is exactly like the one that would be build by standalone C4.5. The
tree build is only made accessible in Python.</p>
<p><a class="reference internal" href="#Orange.classification.tree.C45Learner" title="Orange.classification.tree.C45Learner"><tt class="xref py py-class docutils literal"><span class="pre">C45Learner</span></tt></a> and <a class="reference internal" href="#Orange.classification.tree.C45Classifier" title="Orange.classification.tree.C45Classifier"><tt class="xref py py-class docutils literal"><span class="pre">C45Classifier</span></tt></a> behave
like any other Orange learner and classifier. Unlike most of Orange
learning algorithms, C4.5 does not accepts weighted instances.</p>
<div class="section" id="building-the-c4-5-plug-in">
<h3>Building the C4.5 plug-in<a class="headerlink" href="#building-the-c4-5-plug-in" title="Permalink to this headline">¶</a></h3>
<p>Due to copyright restrictions, C4.5 is not distributed with Orange,
but it can be added as a plug-in. A C compiler is needed for the
procedure: on Windows MS Visual C (CL.EXE and LINK.EXE must be on the
PATH), on Linux and OS X gcc (OS X users can download it from Apple).</p>
<p>Orange must be installed prior to building C4.5.</p>
<ol class="arabic simple">
<li>Download
<a class="reference external" href="http://www.rulequest.com/Personal/c4.5r8.tar.gz">C4.5 (Release 8) sources</a>
from the <a class="reference external" href="http://www.rulequest.com/">Rule Quest&#8217;s site</a> and extract
them. The files will be modified in the
further process.</li>
<li>Download
<a class="reference external" href="http://orange.biolab.si/trac/browser/orange/Orange/orng/ensemble.c?format=txt">ensemble.c</a>
and <a class="reference external" href="http://orange.biolab.si/trac/browser/orange/Orange/orng/buildC45.py?format=txt">buildC45.py</a>
into the directory R8/Src of the C4.5 sources
(this directory contains, for instance, the file average.c).</li>
<li>Run buildC45.py, which will build the plug-in and put it next to
orange.pyd (or orange.so on Linux/Mac).</li>
<li>Run python, type <tt class="docutils literal"><span class="pre">import</span> <span class="pre">Orange</span></tt> and
create <tt class="docutils literal"><span class="pre">Orange.classification.tree.C45Learner()</span></tt>. This should
succeed.</li>
<li>Finally, you can remove C4.5 sources.</li>
</ol>
<p>The buildC45.py creates .h files that wrap Quinlan&#8217;s .i files and
ensure that they are not included twice. It modifies C4.5 sources to
include .h&#8217;s instead of .i&#8217;s (this step can hardly fail). Then it compiles
ensemble.c into c45.dll or c45.so and puts it next to Orange.</p>
<dl class="class">
<dt id="Orange.classification.tree.C45Learner">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">C45Learner</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#Orange.classification.tree.C45Learner" title="Orange.classification.tree.C45Learner"><tt class="xref py py-class docutils literal"><span class="pre">C45Learner</span></tt></a>&#8216;s attributes have double names - those that
you know from C4.5 command lines and the corresponding names of C4.5&#8217;s
internal variables. All defaults are set as in C4.5; if you change
nothing, you are running C4.5.</p>
<p>Constructs a <a class="reference internal" href="#Orange.classification.tree.C45Classifier" title="Orange.classification.tree.C45Classifier"><tt class="xref py py-obj docutils literal"><span class="pre">C45Classifier</span></tt></a> when given data.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.gain_ratio">
<tt class="descname">gain_ratio</tt><big>(</big><em>g</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.gain_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether to use information gain (false, default)
or gain ratio for selection of attributes (true).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.batch">
<tt class="descname">batch</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn on batch mode (no windows, no iterations); this option is
not documented in C4.5 manuals. It conflicts with &#8220;window&#8221;,
&#8220;increment&#8221; and &#8220;trials&#8221;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.subset">
<tt class="descname">subset</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables subsetting (default: false, no subsetting),</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.prob_thresh">
<tt class="descname">prob_thresh</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.prob_thresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Probabilistic threshold for continuous attributes (default: false).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.min_objs">
<tt class="descname">min_objs</tt><big>(</big><em>m</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.min_objs" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimal number of objects (instances) in leaves (default: 2).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.window">
<tt class="descname">window</tt><big>(</big><em>w</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.window" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial windows size (default: maximum of 20% and twice the
square root of the number of data objects).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.increment">
<tt class="descname">increment</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.increment" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of objects that can be added to the window
at each iteration (default: 20% of the initial window size).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.cf">
<tt class="descname">cf</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.cf" title="Permalink to this definition">¶</a></dt>
<dd><p>Prunning confidence level (default: 25%).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.trials">
<tt class="descname">trials</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.trials" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of trials in iterative (i.e. non-batch) mode (default: 10).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Learner.prune">
<tt class="descname">prune</tt><a class="headerlink" href="#Orange.classification.tree.C45Learner.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pruned tree (not an original C4.5 option) (default: true)</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.C45Learner.commandline">
<tt class="descname">commandline</tt><big>(</big><em>ln</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Learner.commandline" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the arguments with a C4.5 command line.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.C45Classifier">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">C45Classifier</tt><big>(</big><em>base_classifier</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>A faithful reimplementation of Quinlan&#8217;s C4.5, but
uses a tree composed of <a class="reference internal" href="#Orange.classification.tree.C45Node" title="Orange.classification.tree.C45Node"><tt class="xref py py-class docutils literal"><span class="pre">C45Node</span></tt></a> instead of C4.5&#8217;s original
tree structure.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.C45Classifier.tree">
<tt class="descname">tree</tt><a class="headerlink" href="#Orange.classification.tree.C45Classifier.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>C4.5 tree stored as <a class="reference internal" href="#Orange.classification.tree.C45Node" title="Orange.classification.tree.C45Node"><tt class="xref py py-obj docutils literal"><span class="pre">C45Node</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.C45Classifier.__call__">
<tt class="descname">__call__</tt><big>(</big><em>instance</em>, <em>result_type=0</em>, <em>*args</em>, <em>**kwdargs</em><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Classifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify a new instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>instance</strong> (<a class="reference internal" href="Orange.data.instance.html#Orange.data.Instance" title="Orange.data.Instance"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Instance</span></tt></a>) &#8211; instance to be classified.</li>
<li><strong>result_type</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetValue</span></tt> or               <tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetProbabilities</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">Orange.classification.Classifier.GetBoth</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a>, 
<tt class="xref py py-class docutils literal"><span class="pre">Orange.statistics.Distribution</span></tt> or a tuple with both</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Orange.classification.tree.C45Classifier.to_string">
<tt class="descname">to_string</tt><big>(</big><big>)</big><a class="headerlink" href="#Orange.classification.tree.C45Classifier.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the tree in the same form as Ross Quinlan&#8217;s 
C4.5 program.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;voting&quot;</span><span class="p">)</span>
<span class="n">c45</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">C45Learner</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span> <span class="n">c45</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-python"><pre>physician-fee-freeze = n: democrat (253.4)
physician-fee-freeze = y:
|   synfuels-corporation-cutback = n: republican (145.7)
|   synfuels-corporation-cutback = y:
|   |   mx-missile = y: democrat (6.0)
|   |   mx-missile = n:
|   |   |   adoption-of-the-budget-resolution = n: republican (22.6)
|   |   |   adoption-of-the-budget-resolution = y:
|   |   |   |   anti-satellite-test-ban = n: democrat (5.0)
|   |   |   |   anti-satellite-test-ban = y: republican (2.2)</pre>
</div>
<p>The standalone C4.5 would print:</p>
<div class="highlight-python"><pre>physician-fee-freeze = n: democrat (253.4/5.9)
physician-fee-freeze = y:
|   synfuels-corporation-cutback = n: republican (145.7/6.2)
|   synfuels-corporation-cutback = y:
|   |   mx-missile = y: democrat (6.0/2.4)
|   |   mx-missile = n:
|   |   |   adoption-of-the-budget-resolution = n: republican (22.6/5.2)
|   |   |   adoption-of-the-budget-resolution = y:
|   |   |   |   anti-satellite-test-ban = n: democrat (5.0/1.2)
|   |   |   |   anti-satellite-test-ban = y: republican (2.2/1.0)</pre>
</div>
<p>C4.5 also prints out the number of errors on learning data in
each node.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Orange.classification.tree.C45Node">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">C45Node</tt><a class="headerlink" href="#Orange.classification.tree.C45Node" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a reimplementation of the corresponding <em>struct</em> from
Quinlan&#8217;s C4.5 code.</p>
<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.node_type">
<tt class="descname">node_type</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the node:  <tt class="xref py py-obj docutils literal"><span class="pre">C45Node.Leaf</span></tt> (0),
<tt class="xref py py-obj docutils literal"><span class="pre">C45Node.Branch</span></tt> (1), <tt class="xref py py-obj docutils literal"><span class="pre">C45Node.Cut</span></tt> (2),
<tt class="xref py py-obj docutils literal"><span class="pre">C45Node.Subset</span></tt> (3). &#8220;Leaves&#8221; are leaves, &#8220;branches&#8221;
split instances based on values of a discrete attribute,
&#8220;cuts&#8221; cut them according to a threshold value of a continuous
attributes and &#8220;subsets&#8221; use discrete attributes but with subsetting
so that several values can go into the same branch.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.leaf">
<tt class="descname">leaf</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Value returned by that leaf. The field is defined for internal
nodes as well.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.items">
<tt class="descname">items</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of (learning) instances in the node.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.class_dist">
<tt class="descname">class_dist</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.class_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Class distribution for the node (of type
<a class="reference internal" href="Orange.statistics.distribution.html#Orange.statistics.distribution.Discrete" title="Orange.statistics.distribution.Discrete"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.statistics.distribution.Discrete</span></tt></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.tested">
<tt class="descname">tested</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.tested" title="Permalink to this definition">¶</a></dt>
<dd><p>The attribute used in the node&#8217;s test. If node is a leaf,
obj:<cite>tested</cite> is None, if node is of type <tt class="xref py py-obj docutils literal"><span class="pre">Branch</span></tt> or <tt class="xref py py-obj docutils literal"><span class="pre">Cut</span></tt>
<a class="reference internal" href="#Orange.classification.tree.C45Node.tested" title="Orange.classification.tree.C45Node.tested"><tt class="xref py py-obj docutils literal"><span class="pre">tested</span></tt></a> is a discrete attribute, and if node is of type
<tt class="xref py py-obj docutils literal"><span class="pre">Cut</span></tt> then <a class="reference internal" href="#Orange.classification.tree.C45Node.tested" title="Orange.classification.tree.C45Node.tested"><tt class="xref py py-obj docutils literal"><span class="pre">tested</span></tt></a> is a continuous attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.cut">
<tt class="descname">cut</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>A threshold for continuous attributes, if node is of type <tt class="xref py py-obj docutils literal"><span class="pre">Cut</span></tt>.
Undefined otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.mapping">
<tt class="descname">mapping</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for nodes of type <tt class="xref py py-obj docutils literal"><span class="pre">Subset</span></tt>. Element <tt class="docutils literal"><span class="pre">mapping[i]</span></tt>
gives the index for an instance whose value of <a class="reference internal" href="#Orange.classification.tree.C45Node.tested" title="Orange.classification.tree.C45Node.tested"><tt class="xref py py-obj docutils literal"><span class="pre">tested</span></tt></a> is <em>i</em>.
Here, <em>i</em> denotes an index of value, not a <a class="reference internal" href="Orange.data.value.html#Orange.data.Value" title="Orange.data.Value"><tt class="xref py py-class docutils literal"><span class="pre">Orange.data.Value</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.C45Node.branch">
<tt class="descname">branch</tt><a class="headerlink" href="#Orange.classification.tree.C45Node.branch" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of branches stemming from this node.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id1">
<h3>Examples<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>This
script constructs the same learner as you would get by calling
the usual C4.5:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;iris&quot;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">C45Learner</span><span class="p">(</span><span class="n">iris</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">C4.5 with default arguments&quot;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iris</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">tree</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">.</span><span class="n">getclass</span><span class="p">()</span>
</pre></div>
</div>
<p>Both C4.5 command-line symbols and variable names can be used. The
following lines produce the same result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">C45Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">C45Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">min_objs</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>A veteran C4.5 might prefer <a class="reference internal" href="#Orange.classification.tree.C45Learner.commandline" title="Orange.classification.tree.C45Learner.commandline"><tt class="xref py py-func docutils literal"><span class="pre">C45Learner.commandline()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lrn</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">C45Learner</span><span class="p">()</span>
<span class="n">lrn</span><span class="o">.</span><span class="n">commandline</span><span class="p">(</span><span class="s">&quot;-m 1 -s&quot;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">lrn</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The following script prints out the tree same format as C4.5 does.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">printTree0</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">classvar</span><span class="p">,</span> <span class="n">lev</span><span class="p">):</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">tested</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> (</span><span class="si">%.1f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">classvar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">leaf</span><span class="p">)],</span> <span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">),</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="s">&quot;|    &quot;</span><span class="o">*</span><span class="n">lev</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">:&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span>
            <span class="n">printTree0</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">classvar</span><span class="p">,</span> <span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="s">&quot;|    &quot;</span><span class="o">*</span><span class="n">lev</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> &amp;lt;= </span><span class="si">%.1f</span><span class="s">:&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">cut</span><span class="p">),</span>
        <span class="n">printTree0</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branch</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">classvar</span><span class="p">,</span> <span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="s">&quot;|    &quot;</span><span class="o">*</span><span class="n">lev</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> &gt; </span><span class="si">%.1f</span><span class="s">:&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">cut</span><span class="p">),</span>
        <span class="n">printTree0</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branch</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">classvar</span><span class="p">,</span> <span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">branch</span><span class="p">):</span>
            <span class="n">inset</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">mapping</span><span class="p">))</span>
            <span class="n">inset</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">inset</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inset</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="s">&quot;|    &quot;</span><span class="o">*</span><span class="n">lev</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">:&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">inset</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="s">&quot;|    &quot;</span><span class="o">*</span><span class="n">lev</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> in {</span><span class="si">%s</span><span class="s">}:&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                    <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="s">&quot;, &quot;</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">inset</span><span class="p">)),</span>
            <span class="n">printTree0</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">classvar</span><span class="p">,</span> <span class="n">lev</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">printTree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">printTree0</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">classVar</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">print</span>
</pre></div>
</div>
<p>For the leaves just the value in <tt class="docutils literal"><span class="pre">node.leaf</span></tt> in printed. Since
<a class="reference internal" href="#Orange.classification.tree.C45Node" title="Orange.classification.tree.C45Node"><tt class="xref py py-obj docutils literal"><span class="pre">C45Node</span></tt></a> does not know to which attribute it belongs, we need to
convert it to a string through <tt class="docutils literal"><span class="pre">classvar</span></tt>, which is passed as an extra
argument to the recursive part of print_tree.</p>
<p>For discrete splits without subsetting, we print out all attribute values
and recursively call the function for all branches. Continuous splits
are equally easy to handle.</p>
<p>For discrete splits with subsetting, we iterate through branches,
retrieve the corresponding values that go into each branch to inset,
turn the values into strings and print them out, separately treating
the case when only a single value goes into the branch.</p>
</div>
</div>
<div class="section" id="simple-tree-inducer">
<h2>Simple Tree Inducer<a class="headerlink" href="#simple-tree-inducer" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#Orange.classification.tree.SimpleTreeLearner" title="Orange.classification.tree.SimpleTreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">SimpleTreeLearner</span></tt></a> is an implementation of regression and classification
trees. It is faster than <a class="reference internal" href="#Orange.classification.tree.TreeLearner" title="Orange.classification.tree.TreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">TreeLearner</span></tt></a> at the expense of flexibility.
It uses gain ratio for classification and MSE for regression.</p>
<p><a class="reference internal" href="#Orange.classification.tree.SimpleTreeLearner" title="Orange.classification.tree.SimpleTreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">SimpleTreeLearner</span></tt></a> was developed for speeding up the construction
of random forests, but can also be used as a standalone tree learner.</p>
<dl class="class">
<dt id="Orange.classification.tree.SimpleTreeLearner">
<em class="property">class </em><tt class="descclassname">Orange.classification.tree.</tt><tt class="descname">SimpleTreeLearner</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="Orange.classification.tree.SimpleTreeLearner.max_majority">
<tt class="descname">max_majority</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner.max_majority" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximal proportion of majority class. When this is exceeded,
induction stops (only used for classification).</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.SimpleTreeLearner.min_instances">
<tt class="descname">min_instances</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner.min_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimal number of instances in leaves. Instance count is weighed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.SimpleTreeLearner.max_depth">
<tt class="descname">max_depth</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner.max_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximal depth of tree.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.SimpleTreeLearner.skip_prob">
<tt class="descname">skip_prob</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner.skip_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>At every split an attribute will be skipped with probability <tt class="docutils literal"><span class="pre">skip_prob</span></tt>.
Useful for building random forests.</p>
</dd></dl>

<dl class="attribute">
<dt id="Orange.classification.tree.SimpleTreeLearner.random_generator">
<tt class="descname">random_generator</tt><a class="headerlink" href="#Orange.classification.tree.SimpleTreeLearner.random_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide your own <a class="reference internal" href="Orange.misc.html#Orange.misc.Random" title="Orange.misc.Random"><tt class="xref py py-obj docutils literal"><span class="pre">Orange.misc.Random</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<div class="section" id="id2">
<h3>Examples<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#Orange.classification.tree.SimpleTreeLearner" title="Orange.classification.tree.SimpleTreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">SimpleTreeLearner</span></tt></a> is used in much the same way as <a class="reference internal" href="#Orange.classification.tree.TreeLearner" title="Orange.classification.tree.TreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">TreeLearner</span></tt></a>.
A typical example of using <a class="reference internal" href="#Orange.classification.tree.SimpleTreeLearner" title="Orange.classification.tree.SimpleTreeLearner"><tt class="xref py py-obj docutils literal"><span class="pre">SimpleTreeLearner</span></tt></a> would be to build a random
forest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">Orange</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">SimpleTreeLearnerSetProb</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Orange.classification.tree.SimpleTreeLearner which sets the skip_prob</span>
<span class="sd">    so that on average a square root of the attributes will be </span>
<span class="sd">    randomly choosen for each split.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">examples</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="o">.</span><span class="n">skip_prob</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">examples</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">examples</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped</span><span class="p">(</span><span class="n">examples</span><span class="p">)</span>

<span class="c">#ordinary random forests</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">TreeLearner</span><span class="p">(</span><span class="n">min_instances</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s">&quot;gainRatio&quot;</span><span class="p">)</span>
<span class="n">rf_def</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">ensemble</span><span class="o">.</span><span class="n">forest</span><span class="o">.</span><span class="n">RandomForestLearner</span><span class="p">(</span><span class="n">trees</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">base_learner</span><span class="o">=</span><span class="n">tree</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;for_gain&quot;</span><span class="p">)</span>

<span class="c">#random forests with simple trees - simple trees do random attribute selection by themselves</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">classification</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">SimpleTreeLearner</span><span class="p">(</span><span class="n">min_instances</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">stp</span> <span class="o">=</span> <span class="n">SimpleTreeLearnerSetProb</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
<span class="n">rf_simple</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">ensemble</span><span class="o">.</span><span class="n">forest</span><span class="o">.</span><span class="n">RandomForestLearner</span><span class="p">(</span><span class="n">learner</span><span class="o">=</span><span class="n">stp</span><span class="p">,</span> <span class="n">trees</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;for_simp&quot;</span><span class="p">)</span>

<span class="n">learners</span> <span class="o">=</span> <span class="p">[</span> <span class="n">rf_def</span><span class="p">,</span> <span class="n">rf_simple</span> <span class="p">]</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s">&quot;iris&quot;</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">Orange</span><span class="o">.</span><span class="n">evaluation</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">cross_validation</span><span class="p">(</span><span class="n">learners</span><span class="p">,</span> <span class="n">iris</span><span class="p">,</span> <span class="n">folds</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Learner  CA     Brier  AUC&quot;</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">learners</span><span class="p">)):</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%-8s</span><span class="s"> </span><span class="si">%5.3f</span><span class="s">  </span><span class="si">%5.3f</span><span class="s">  </span><span class="si">%5.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">learners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> \
    <span class="n">Orange</span><span class="o">.</span><span class="n">evaluation</span><span class="o">.</span><span class="n">scoring</span><span class="o">.</span><span class="n">CA</span><span class="p">(</span><span class="n">results</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> 
    <span class="n">Orange</span><span class="o">.</span><span class="n">evaluation</span><span class="o">.</span><span class="n">scoring</span><span class="o">.</span><span class="n">Brier_score</span><span class="p">(</span><span class="n">results</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span>
    <span class="n">Orange</span><span class="o">.</span><span class="n">evaluation</span><span class="o">.</span><span class="n">scoring</span><span class="o">.</span><span class="n">AUC</span><span class="p">(</span><span class="n">results</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>

<span class="k">print</span> 

<span class="k">print</span> <span class="s">&quot;Runtimes:&quot;</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">learners</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">l</span><span class="p">(</span><span class="n">iris</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">l</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>Bratko, I. (2002). <cite>Prolog Programming for Artificial Intelligence</cite>, Addison
Wesley, 2002.</p>
<p>E Koutsofios, SC North. Drawing Graphs with dot. AT&amp;T Bell Laboratories,
Murray Hill NJ, U.S.A., October 1993.</p>
<p><a class="reference external" href="http://www.research.att.com/sw/tools/graphviz/">Graphviz - open source graph drawing software</a>
A home page of AT&amp;T&#8217;s dot and similar software packages.</p>
<p>&#8220;&#8221;&#8220;</p>
<p>&#8220;&#8221;&#8221;
TODO C++ aliases</p>
<p>SplitConstructor.discrete/continuous_split_constructor -&gt; SplitConstructor.discrete
Node.examples -&gt; Node.instances</p>
</div>
</div>



          </div>
        </div>
      </div> 
      <div class="clearer"></div>
    </div>  
	
    <div class="footer">
    </div>
	            </div>
        </div>
        <div class="border1"></div>
        <div class="border2"></div>
    </div>
</div>

  </body>
</html>